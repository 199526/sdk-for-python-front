# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------

from msrest.serialization import Model
from msrest.exceptions import HttpOperationError


class ApprenticeLearningMetrics(Model):
    """ApprenticeLearningMetrics.

    All required parameters must be populated in order to send to Azure.

    :param number_of_events: Required.
    :type number_of_events: long
    :param sum_of_rewards: Required.
    :type sum_of_rewards: float
    :param number_of_imitated_events: Required.
    :type number_of_imitated_events: long
    :param sum_of_imitated_rewards: Required.
    :type sum_of_imitated_rewards: float
    """

    _validation = {
        'number_of_events': {'required': True},
        'sum_of_rewards': {'required': True},
        'number_of_imitated_events': {'required': True},
        'sum_of_imitated_rewards': {'required': True},
    }

    _attribute_map = {
        'number_of_events': {'key': 'numberOfEvents', 'type': 'long'},
        'sum_of_rewards': {'key': 'sumOfRewards', 'type': 'float'},
        'number_of_imitated_events': {'key': 'numberOfImitatedEvents', 'type': 'long'},
        'sum_of_imitated_rewards': {'key': 'sumOfImitatedRewards', 'type': 'float'},
    }

    def __init__(self, *, number_of_events: int, sum_of_rewards: float, number_of_imitated_events: int, sum_of_imitated_rewards: float, **kwargs) -> None:
        super(ApprenticeLearningMetrics, self).__init__(**kwargs)
        self.number_of_events = number_of_events
        self.sum_of_rewards = sum_of_rewards
        self.number_of_imitated_events = number_of_imitated_events
        self.sum_of_imitated_rewards = sum_of_imitated_rewards


class ApprenticeModeMetrics(Model):
    """ApprenticeModeMetrics.

    All required parameters must be populated in order to send to Azure.

    :param start_time: Required.
    :type start_time: datetime
    :param last_processed_event_time: Required.
    :type last_processed_event_time: datetime
    :param last_batch_metrics:
    :type last_batch_metrics:
     ~azure.cognitiveservices.personalizer.models.ApprenticeLearningMetrics
    :param number_of_events: Required.
    :type number_of_events: long
    :param sum_of_rewards: Required.
    :type sum_of_rewards: float
    :param number_of_imitated_events: Required.
    :type number_of_imitated_events: long
    :param sum_of_imitated_rewards: Required.
    :type sum_of_imitated_rewards: float
    """

    _validation = {
        'start_time': {'required': True},
        'last_processed_event_time': {'required': True},
        'number_of_events': {'required': True},
        'sum_of_rewards': {'required': True},
        'number_of_imitated_events': {'required': True},
        'sum_of_imitated_rewards': {'required': True},
    }

    _attribute_map = {
        'start_time': {'key': 'startTime', 'type': 'iso-8601'},
        'last_processed_event_time': {'key': 'lastProcessedEventTime', 'type': 'iso-8601'},
        'last_batch_metrics': {'key': 'lastBatchMetrics', 'type': 'ApprenticeLearningMetrics'},
        'number_of_events': {'key': 'numberOfEvents', 'type': 'long'},
        'sum_of_rewards': {'key': 'sumOfRewards', 'type': 'float'},
        'number_of_imitated_events': {'key': 'numberOfImitatedEvents', 'type': 'long'},
        'sum_of_imitated_rewards': {'key': 'sumOfImitatedRewards', 'type': 'float'},
    }

    def __init__(self, *, start_time, last_processed_event_time, number_of_events: int, sum_of_rewards: float, number_of_imitated_events: int, sum_of_imitated_rewards: float, last_batch_metrics=None, **kwargs) -> None:
        super(ApprenticeModeMetrics, self).__init__(**kwargs)
        self.start_time = start_time
        self.last_processed_event_time = last_processed_event_time
        self.last_batch_metrics = last_batch_metrics
        self.number_of_events = number_of_events
        self.sum_of_rewards = sum_of_rewards
        self.number_of_imitated_events = number_of_imitated_events
        self.sum_of_imitated_rewards = sum_of_imitated_rewards


class DateRange(Model):
    """A date range starting at From and ending at To.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar from_property: Start date for the range.
    :vartype from_property: datetime
    :ivar to: End date for the range.
    :vartype to: datetime
    """

    _validation = {
        'from_property': {'readonly': True},
        'to': {'readonly': True},
    }

    _attribute_map = {
        'from_property': {'key': 'from', 'type': 'iso-8601'},
        'to': {'key': 'to', 'type': 'iso-8601'},
    }

    def __init__(self, **kwargs) -> None:
        super(DateRange, self).__init__(**kwargs)
        self.from_property = None
        self.to = None


class ErrorResponse(Model):
    """Used to return an error to the client.

    All required parameters must be populated in order to send to Azure.

    :param error: Required.
    :type error:
     ~azure.cognitiveservices.personalizer.models.PersonalizerError
    """

    _validation = {
        'error': {'required': True},
    }

    _attribute_map = {
        'error': {'key': 'error', 'type': 'PersonalizerError'},
    }

    def __init__(self, *, error, **kwargs) -> None:
        super(ErrorResponse, self).__init__(**kwargs)
        self.error = error


class ErrorResponseException(HttpOperationError):
    """Server responsed with exception of type: 'ErrorResponse'.

    :param deserialize: A deserializer
    :param response: Server response to be deserialized.
    """

    def __init__(self, deserialize, response, *args):

        super(ErrorResponseException, self).__init__(deserialize, response, 'ErrorResponse', *args)


class Evaluation(Model):
    """A counterfactual evaluation.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar id: The ID of the evaluation.
    :vartype id: str
    :ivar name: The name of the evaluation.
    :vartype name: str
    :ivar start_time: The start time of the evaluation.
    :vartype start_time: datetime
    :ivar end_time: The end time of the evaluation.
    :vartype end_time: datetime
    :ivar job_id: The ID of the job processing the evaluation.
    :vartype job_id: str
    :ivar status: The status of the job processing the evaluation. Possible
     values include: 'completed', 'pending', 'failed', 'notSubmitted',
     'timeout', 'optimalPolicyApplied', 'onlinePolicyRetained'
    :vartype status: str or
     ~azure.cognitiveservices.personalizer.models.EvaluationJobStatus
    :param policy_results: The results of the evaluation.
    :type policy_results:
     list[~azure.cognitiveservices.personalizer.models.PolicyResult]
    :param feature_importance:
    :type feature_importance: list[list[str]]
    :param evaluation_type: Possible values include: 'Manual', 'Auto'
    :type evaluation_type: str or
     ~azure.cognitiveservices.personalizer.models.EvaluationType
    :param optimal_policy:
    :type optimal_policy: str
    :param creation_time:
    :type creation_time: datetime
    """

    _validation = {
        'id': {'readonly': True, 'max_length': 256},
        'name': {'readonly': True, 'max_length': 256},
        'start_time': {'readonly': True},
        'end_time': {'readonly': True},
        'job_id': {'readonly': True},
        'status': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'start_time': {'key': 'startTime', 'type': 'iso-8601'},
        'end_time': {'key': 'endTime', 'type': 'iso-8601'},
        'job_id': {'key': 'jobId', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'policy_results': {'key': 'policyResults', 'type': '[PolicyResult]'},
        'feature_importance': {'key': 'featureImportance', 'type': '[[str]]'},
        'evaluation_type': {'key': 'evaluationType', 'type': 'str'},
        'optimal_policy': {'key': 'optimalPolicy', 'type': 'str'},
        'creation_time': {'key': 'creationTime', 'type': 'iso-8601'},
    }

    def __init__(self, *, policy_results=None, feature_importance=None, evaluation_type=None, optimal_policy: str=None, creation_time=None, **kwargs) -> None:
        super(Evaluation, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.start_time = None
        self.end_time = None
        self.job_id = None
        self.status = None
        self.policy_results = policy_results
        self.feature_importance = feature_importance
        self.evaluation_type = evaluation_type
        self.optimal_policy = optimal_policy
        self.creation_time = creation_time


class EvaluationContract(Model):
    """A counterfactual evaluation.

    All required parameters must be populated in order to send to Azure.

    :param enable_offline_experimentation: True if the evaluation should
     explore for a more optimal learning settings.
    :type enable_offline_experimentation: bool
    :param name: Required. The name of the evaluation.
    :type name: str
    :param start_time: Required. The start time of the evaluation.
    :type start_time: datetime
    :param end_time: Required. The end time of the evaluation.
    :type end_time: datetime
    :param policies: Required. Additional learning settings to evaluate.
    :type policies:
     list[~azure.cognitiveservices.personalizer.models.PolicyContract]
    """

    _validation = {
        'name': {'required': True, 'max_length': 256},
        'start_time': {'required': True},
        'end_time': {'required': True},
        'policies': {'required': True},
    }

    _attribute_map = {
        'enable_offline_experimentation': {'key': 'enableOfflineExperimentation', 'type': 'bool'},
        'name': {'key': 'name', 'type': 'str'},
        'start_time': {'key': 'startTime', 'type': 'iso-8601'},
        'end_time': {'key': 'endTime', 'type': 'iso-8601'},
        'policies': {'key': 'policies', 'type': '[PolicyContract]'},
    }

    def __init__(self, *, name: str, start_time, end_time, policies, enable_offline_experimentation: bool=None, **kwargs) -> None:
        super(EvaluationContract, self).__init__(**kwargs)
        self.enable_offline_experimentation = enable_offline_experimentation
        self.name = name
        self.start_time = start_time
        self.end_time = end_time
        self.policies = policies


class InternalError(Model):
    """An object containing more specific information than the parent object about
    the error.

    :param code: Detailed error code.
    :type code: str
    :param innererror:
    :type innererror:
     ~azure.cognitiveservices.personalizer.models.InternalError
    """

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'innererror': {'key': 'innererror', 'type': 'InternalError'},
    }

    def __init__(self, *, code: str=None, innererror=None, **kwargs) -> None:
        super(InternalError, self).__init__(**kwargs)
        self.code = code
        self.innererror = innererror


class LogsProperties(Model):
    """Properties related to data used to train the model.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar date_range:
    :vartype date_range:
     ~azure.cognitiveservices.personalizer.models.LogsPropertiesDateRange
    """

    _validation = {
        'date_range': {'readonly': True},
    }

    _attribute_map = {
        'date_range': {'key': 'dateRange', 'type': 'LogsPropertiesDateRange'},
    }

    def __init__(self, **kwargs) -> None:
        super(LogsProperties, self).__init__(**kwargs)
        self.date_range = None


class LogsPropertiesDateRange(DateRange):
    """LogsPropertiesDateRange.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar from_property: Start date for the range.
    :vartype from_property: datetime
    :ivar to: End date for the range.
    :vartype to: datetime
    """

    _validation = {
        'from_property': {'readonly': True},
        'to': {'readonly': True},
    }

    _attribute_map = {
        'from_property': {'key': 'from', 'type': 'iso-8601'},
        'to': {'key': 'to', 'type': 'iso-8601'},
    }

    def __init__(self, **kwargs) -> None:
        super(LogsPropertiesDateRange, self).__init__(**kwargs)


class ModelProperties(Model):
    """Properties related to the trained model.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar creation_time: Creation time of the model.
    :vartype creation_time: datetime
    :ivar last_modified_time: Last time the model was modified.
    :vartype last_modified_time: datetime
    """

    _validation = {
        'creation_time': {'readonly': True},
        'last_modified_time': {'readonly': True},
    }

    _attribute_map = {
        'creation_time': {'key': 'creationTime', 'type': 'iso-8601'},
        'last_modified_time': {'key': 'lastModifiedTime', 'type': 'iso-8601'},
    }

    def __init__(self, **kwargs) -> None:
        super(ModelProperties, self).__init__(**kwargs)
        self.creation_time = None
        self.last_modified_time = None


class MultiSlotRankRequest(Model):
    """MultiSlotRankRequest.

    All required parameters must be populated in order to send to Azure.

    :param context_features: Features of the context used for Personalizer as
     a
     dictionary of dictionaries. This is determined by your application, and
     typically includes features about the current user, their
     device, profile information, aggregated data about time and date, etc.
     Features should not include personally identifiable information (PII),
     unique UserIDs, or precise timestamps.
    :type context_features: list[object]
    :param actions: Required. The set of actions the Personalizer service can
     pick from.
     The set should not contain more than 50 actions.
     The order of the actions does not affect the rank result but the order
     should match the sequence your application would have used to display
     them.
     The first item in the array will be used as Baseline item in Offline
     Evaluations.
    :type actions:
     list[~azure.cognitiveservices.personalizer.models.RankableAction]
    :param slots: Required. The set of slots the Personalizer service should
     select actions for.
     The set should not contain more than 50 slots.
    :type slots:
     list[~azure.cognitiveservices.personalizer.models.SlotRequest]
    :param event_id: Optionally pass an eventId that uniquely identifies this
     Rank event.
     If null, the service generates a unique eventId. The eventId will be used
     for
     associating this request with its reward, as well as seeding the
     pseudo-random
     generator when making a Personalizer call.
    :type event_id: str
    :param defer_activation: Send false if it is certain the rewardActionId in
     rank results will be shown to the user, therefore
     Personalizer will expect a Reward call, otherwise it will assign the
     default
     Reward to the event. Send true if it is possible the user will not see the
     action specified in the rank results,
     (e.g. because the page is rendering later, or the Rank results may be
     overridden by code further downstream).
     You must call the Activate Event API if the event output is shown to
     users, otherwise Rewards will be ignored. Default value: False .
    :type defer_activation: bool
    """

    _validation = {
        'actions': {'required': True},
        'slots': {'required': True},
        'event_id': {'max_length': 256},
    }

    _attribute_map = {
        'context_features': {'key': 'contextFeatures', 'type': '[object]'},
        'actions': {'key': 'actions', 'type': '[RankableAction]'},
        'slots': {'key': 'slots', 'type': '[SlotRequest]'},
        'event_id': {'key': 'eventId', 'type': 'str'},
        'defer_activation': {'key': 'deferActivation', 'type': 'bool'},
    }

    def __init__(self, *, actions, slots, context_features=None, event_id: str=None, defer_activation: bool=False, **kwargs) -> None:
        super(MultiSlotRankRequest, self).__init__(**kwargs)
        self.context_features = context_features
        self.actions = actions
        self.slots = slots
        self.event_id = event_id
        self.defer_activation = defer_activation


class MultiSlotRankResponse(Model):
    """MultiSlotRankResponse.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar slots: Each slot has a corresponding rewardActionID which is the
     action ID recommended by Personalizer.
    :vartype slots:
     list[~azure.cognitiveservices.personalizer.models.SlotResponse]
    :ivar event_id: The eventId for the round trip from request to response.
    :vartype event_id: str
    """

    _validation = {
        'slots': {'readonly': True},
        'event_id': {'readonly': True, 'max_length': 256},
    }

    _attribute_map = {
        'slots': {'key': 'slots', 'type': '[SlotResponse]'},
        'event_id': {'key': 'eventId', 'type': 'str'},
    }

    def __init__(self, **kwargs) -> None:
        super(MultiSlotRankResponse, self).__init__(**kwargs)
        self.slots = None
        self.event_id = None


class MultiSlotRewardRequest(Model):
    """Reward given to a list of slots.

    All required parameters must be populated in order to send to Azure.

    :param reward: Required.
    :type reward:
     list[~azure.cognitiveservices.personalizer.models.SlotReward]
    """

    _validation = {
        'reward': {'required': True},
    }

    _attribute_map = {
        'reward': {'key': 'reward', 'type': '[SlotReward]'},
    }

    def __init__(self, *, reward, **kwargs) -> None:
        super(MultiSlotRewardRequest, self).__init__(**kwargs)
        self.reward = reward


class PersonalizerError(Model):
    """The error object.

    All required parameters must be populated in order to send to Azure.

    :param code: Required. Error Codes returned by Personalizer. Possible
     values include: 'BadRequest', 'InvalidServiceConfiguration',
     'InvalidLearningModeServiceConfiguration', 'InvalidPolicyConfiguration',
     'InvalidPolicyContract', 'InvalidEvaluationContract',
     'DuplicateCustomPolicyNames', 'NoLogsExistInDateRange',
     'LogsSizeExceedAllowedLimit', 'InvalidRewardRequest',
     'InvalidEventIdToActivate', 'InvalidRankRequest',
     'InvalidExportLogsRequest', 'InvalidContainer', 'InvalidModelMetadata',
     'ApprenticeModeNeverTurnedOn', 'MissingAppId', 'InvalidRewardWaitTime',
     'InvalidMultiSlotApiAccess', 'ModelFileAccessDenied',
     'ProblemTypeIncompatibleWithAutoOptimization', 'ResourceNotFound',
     'FrontEndNotFound', 'EvaluationNotFound', 'LearningSettingsNotFound',
     'EvaluationModelNotFound', 'LogsPropertiesNotFound', 'ModelRankingError',
     'InternalServerError', 'RankNullResponse', 'UpdateConfigurationFailed',
     'ModelResetFailed', 'ModelPublishFailed', 'ModelMetadataUpdateFailed',
     'OperationNotAllowed'
    :type code: str or
     ~azure.cognitiveservices.personalizer.models.PersonalizerErrorCode
    :param message: Required. A message explaining the error reported by the
     service.
    :type message: str
    :param target: Error source element.
    :type target: str
    :param details: An array of details about specific errors that led to this
     reported error.
    :type details:
     list[~azure.cognitiveservices.personalizer.models.PersonalizerError]
    :param inner_error:
    :type inner_error:
     ~azure.cognitiveservices.personalizer.models.InternalError
    """

    _validation = {
        'code': {'required': True},
        'message': {'required': True},
    }

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
        'target': {'key': 'target', 'type': 'str'},
        'details': {'key': 'details', 'type': '[PersonalizerError]'},
        'inner_error': {'key': 'innerError', 'type': 'InternalError'},
    }

    def __init__(self, *, code, message: str, target: str=None, details=None, inner_error=None, **kwargs) -> None:
        super(PersonalizerError, self).__init__(**kwargs)
        self.code = code
        self.message = message
        self.target = target
        self.details = details
        self.inner_error = inner_error


class PolicyContract(Model):
    """Learning settings specifying how to train the model.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. Name of the learning settings.
    :type name: str
    :param arguments: Required. Arguments of the learning settings.
    :type arguments: str
    """

    _validation = {
        'name': {'required': True, 'max_length': 256},
        'arguments': {'required': True, 'max_length': 1024},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'arguments': {'key': 'arguments', 'type': 'str'},
    }

    def __init__(self, *, name: str, arguments: str, **kwargs) -> None:
        super(PolicyContract, self).__init__(**kwargs)
        self.name = name
        self.arguments = arguments


class PolicyReferenceContract(Model):
    """Reference to the policy within the evaluation.

    All required parameters must be populated in order to send to Azure.

    :param evaluation_id: Required. Evaluation Id of the evaluation.
    :type evaluation_id: str
    :param policy_name: Required. Name of the learning settings.
    :type policy_name: str
    """

    _validation = {
        'evaluation_id': {'required': True, 'max_length': 256},
        'policy_name': {'required': True, 'max_length': 256},
    }

    _attribute_map = {
        'evaluation_id': {'key': 'evaluationId', 'type': 'str'},
        'policy_name': {'key': 'policyName', 'type': 'str'},
    }

    def __init__(self, *, evaluation_id: str, policy_name: str, **kwargs) -> None:
        super(PolicyReferenceContract, self).__init__(**kwargs)
        self.evaluation_id = evaluation_id
        self.policy_name = policy_name


class PolicyResult(Model):
    """This class contains the Learning Settings information and the results of
    the Offline Evaluation using that policy.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar name: The name of the Learning Settings.
    :vartype name: str
    :ivar arguments: The arguments of the Learning Settings.
    :vartype arguments: str
    :ivar policy_source: The source of the Learning Settings. Possible values
     include: 'Online', 'Baseline', 'Random', 'Custom',
     'OfflineExperimentation'
    :vartype policy_source: str or
     ~azure.cognitiveservices.personalizer.models.PolicySource
    :ivar summary: The aggregate results of the Offline Evaluation.
    :vartype summary:
     list[~azure.cognitiveservices.personalizer.models.PolicyResultSummary]
    :ivar total_summary:
    :vartype total_summary:
     ~azure.cognitiveservices.personalizer.models.PolicyResultTotalSummary
    """

    _validation = {
        'name': {'readonly': True},
        'arguments': {'readonly': True},
        'policy_source': {'readonly': True},
        'summary': {'readonly': True},
        'total_summary': {'readonly': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'arguments': {'key': 'arguments', 'type': 'str'},
        'policy_source': {'key': 'policySource', 'type': 'str'},
        'summary': {'key': 'summary', 'type': '[PolicyResultSummary]'},
        'total_summary': {'key': 'totalSummary', 'type': 'PolicyResultTotalSummary'},
    }

    def __init__(self, **kwargs) -> None:
        super(PolicyResult, self).__init__(**kwargs)
        self.name = None
        self.arguments = None
        self.policy_source = None
        self.summary = None
        self.total_summary = None


class PolicyResultSummary(Model):
    """This class contains the summary of evaluating a policy on a counterfactual
    evaluation.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar time_stamp: Timestamp of the aggregation.
    :vartype time_stamp: datetime
    :ivar ips_estimator_numerator: Numerator for IPS estimator.
    :vartype ips_estimator_numerator: float
    :ivar ips_estimator_denominator: Denominator for IPS estimator.
    :vartype ips_estimator_denominator: float
    :ivar snips_estimator_denominator: Denominator for SNIPS estimator.
    :vartype snips_estimator_denominator: float
    :ivar aggregate_time_window: Time window for aggregation.
     For example, PT5M (5 mins). For information about the time format,
     see http://en.wikipedia.org/wiki/ISO_8601#Durations
    :vartype aggregate_time_window: timedelta
    :param non_zero_probability: Probability of non-zero values for the Policy
     evaluation.
    :type non_zero_probability: float
    :ivar sum_of_squares: Sum of Squares for the Policy evaluation results.
    :vartype sum_of_squares: float
    :ivar confidence_interval: Gaussian confidence interval for the Policy
     evaluation.
    :vartype confidence_interval: float
    :ivar average_reward: Average reward.
    :vartype average_reward: float
    """

    _validation = {
        'time_stamp': {'readonly': True},
        'ips_estimator_numerator': {'readonly': True},
        'ips_estimator_denominator': {'readonly': True},
        'snips_estimator_denominator': {'readonly': True},
        'aggregate_time_window': {'readonly': True},
        'sum_of_squares': {'readonly': True},
        'confidence_interval': {'readonly': True},
        'average_reward': {'readonly': True},
    }

    _attribute_map = {
        'time_stamp': {'key': 'timeStamp', 'type': 'iso-8601'},
        'ips_estimator_numerator': {'key': 'ipsEstimatorNumerator', 'type': 'float'},
        'ips_estimator_denominator': {'key': 'ipsEstimatorDenominator', 'type': 'float'},
        'snips_estimator_denominator': {'key': 'snipsEstimatorDenominator', 'type': 'float'},
        'aggregate_time_window': {'key': 'aggregateTimeWindow', 'type': 'duration'},
        'non_zero_probability': {'key': 'nonZeroProbability', 'type': 'float'},
        'sum_of_squares': {'key': 'sumOfSquares', 'type': 'float'},
        'confidence_interval': {'key': 'confidenceInterval', 'type': 'float'},
        'average_reward': {'key': 'averageReward', 'type': 'float'},
    }

    def __init__(self, *, non_zero_probability: float=None, **kwargs) -> None:
        super(PolicyResultSummary, self).__init__(**kwargs)
        self.time_stamp = None
        self.ips_estimator_numerator = None
        self.ips_estimator_denominator = None
        self.snips_estimator_denominator = None
        self.aggregate_time_window = None
        self.non_zero_probability = non_zero_probability
        self.sum_of_squares = None
        self.confidence_interval = None
        self.average_reward = None


class PolicyResultTotalSummary(PolicyResultSummary):
    """PolicyResultTotalSummary.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar time_stamp: Timestamp of the aggregation.
    :vartype time_stamp: datetime
    :ivar ips_estimator_numerator: Numerator for IPS estimator.
    :vartype ips_estimator_numerator: float
    :ivar ips_estimator_denominator: Denominator for IPS estimator.
    :vartype ips_estimator_denominator: float
    :ivar snips_estimator_denominator: Denominator for SNIPS estimator.
    :vartype snips_estimator_denominator: float
    :ivar aggregate_time_window: Time window for aggregation.
     For example, PT5M (5 mins). For information about the time format,
     see http://en.wikipedia.org/wiki/ISO_8601#Durations
    :vartype aggregate_time_window: timedelta
    :param non_zero_probability: Probability of non-zero values for the Policy
     evaluation.
    :type non_zero_probability: float
    :ivar sum_of_squares: Sum of Squares for the Policy evaluation results.
    :vartype sum_of_squares: float
    :ivar confidence_interval: Gaussian confidence interval for the Policy
     evaluation.
    :vartype confidence_interval: float
    :ivar average_reward: Average reward.
    :vartype average_reward: float
    """

    _validation = {
        'time_stamp': {'readonly': True},
        'ips_estimator_numerator': {'readonly': True},
        'ips_estimator_denominator': {'readonly': True},
        'snips_estimator_denominator': {'readonly': True},
        'aggregate_time_window': {'readonly': True},
        'sum_of_squares': {'readonly': True},
        'confidence_interval': {'readonly': True},
        'average_reward': {'readonly': True},
    }

    _attribute_map = {
        'time_stamp': {'key': 'timeStamp', 'type': 'iso-8601'},
        'ips_estimator_numerator': {'key': 'ipsEstimatorNumerator', 'type': 'float'},
        'ips_estimator_denominator': {'key': 'ipsEstimatorDenominator', 'type': 'float'},
        'snips_estimator_denominator': {'key': 'snipsEstimatorDenominator', 'type': 'float'},
        'aggregate_time_window': {'key': 'aggregateTimeWindow', 'type': 'duration'},
        'non_zero_probability': {'key': 'nonZeroProbability', 'type': 'float'},
        'sum_of_squares': {'key': 'sumOfSquares', 'type': 'float'},
        'confidence_interval': {'key': 'confidenceInterval', 'type': 'float'},
        'average_reward': {'key': 'averageReward', 'type': 'float'},
    }

    def __init__(self, *, non_zero_probability: float=None, **kwargs) -> None:
        super(PolicyResultTotalSummary, self).__init__(non_zero_probability=non_zero_probability, **kwargs)


class RankableAction(Model):
    """An action with its associated features used for ranking.

    All required parameters must be populated in order to send to Azure.

    :param id: Required. Id of the action.
    :type id: str
    :param features: Required. List of dictionaries containing features.
    :type features: list[object]
    """

    _validation = {
        'id': {'required': True, 'max_length': 256},
        'features': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'features': {'key': 'features', 'type': '[object]'},
    }

    def __init__(self, *, id: str, features, **kwargs) -> None:
        super(RankableAction, self).__init__(**kwargs)
        self.id = id
        self.features = features


class RankedAction(Model):
    """A ranked action with its resulting probability.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar id: Id of the action
    :vartype id: str
    :ivar probability: Probability of the action
    :vartype probability: float
    """

    _validation = {
        'id': {'readonly': True, 'max_length': 256},
        'probability': {'readonly': True, 'maximum': 1, 'minimum': 0},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'probability': {'key': 'probability', 'type': 'float'},
    }

    def __init__(self, **kwargs) -> None:
        super(RankedAction, self).__init__(**kwargs)
        self.id = None
        self.probability = None


class RankRequest(Model):
    """Request a set of actions to be ranked by the Personalizer service.

    All required parameters must be populated in order to send to Azure.

    :param context_features: Features of the context used for Personalizer as
     a
     dictionary of dictionaries. This is determined by your application, and
     typically includes features about the current user, their
     device, profile information, aggregated data about time and date, etc.
     Features should not include personally identifiable information (PII),
     unique UserIDs, or precise timestamps.
    :type context_features: list[object]
    :param actions: Required. The set of actions the Personalizer service can
     pick from.
     The set should not contain more than 50 actions.
     The order of the actions does not affect the rank result but the order
     should match the sequence your application would have used to display
     them.
     The first item in the array will be used as Baseline item in Offline
     Evaluations.
    :type actions:
     list[~azure.cognitiveservices.personalizer.models.RankableAction]
    :param excluded_actions: The set of action ids to exclude from ranking.
     Personalizer will consider the first non-excluded item in the array as the
     Baseline action when performing Offline Evaluations.
    :type excluded_actions: list[str]
    :param event_id: Optionally pass an eventId that uniquely identifies this
     Rank event.
     If null, the service generates a unique eventId. The eventId will be used
     for
     associating this request with its reward, as well as seeding the
     pseudo-random
     generator when making a Personalizer call.
    :type event_id: str
    :param defer_activation: Send false if it is certain the rewardActionId in
     rank results will be shown to the user, therefore
     Personalizer will expect a Reward call, otherwise it will assign the
     default
     Reward to the event. Send true if it is possible the user will not see the
     action specified in the rank results,
     (e.g. because the page is rendering later, or the Rank results may be
     overridden by code further downstream).
     You must call the Activate Event API if the event output is shown to
     users, otherwise Rewards will be ignored. Default value: False .
    :type defer_activation: bool
    """

    _validation = {
        'actions': {'required': True},
        'event_id': {'max_length': 256},
    }

    _attribute_map = {
        'context_features': {'key': 'contextFeatures', 'type': '[object]'},
        'actions': {'key': 'actions', 'type': '[RankableAction]'},
        'excluded_actions': {'key': 'excludedActions', 'type': '[str]'},
        'event_id': {'key': 'eventId', 'type': 'str'},
        'defer_activation': {'key': 'deferActivation', 'type': 'bool'},
    }

    def __init__(self, *, actions, context_features=None, excluded_actions=None, event_id: str=None, defer_activation: bool=False, **kwargs) -> None:
        super(RankRequest, self).__init__(**kwargs)
        self.context_features = context_features
        self.actions = actions
        self.excluded_actions = excluded_actions
        self.event_id = event_id
        self.defer_activation = defer_activation


class RankResponse(Model):
    """Returns which action to use as rewardActionId, and additional information
    about each action as a result of a Rank request.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar ranking: The calculated ranking for the current request.
    :vartype ranking:
     list[~azure.cognitiveservices.personalizer.models.RankedAction]
    :ivar event_id: The eventId for the round trip from request to response.
    :vartype event_id: str
    :ivar reward_action_id: The action chosen by the Personalizer service.
     This is the action your application should display, and for which to
     report the reward.
     This might not be the first found in 'ranking'.
    :vartype reward_action_id: str
    """

    _validation = {
        'ranking': {'readonly': True},
        'event_id': {'readonly': True, 'max_length': 256},
        'reward_action_id': {'readonly': True, 'max_length': 256},
    }

    _attribute_map = {
        'ranking': {'key': 'ranking', 'type': '[RankedAction]'},
        'event_id': {'key': 'eventId', 'type': 'str'},
        'reward_action_id': {'key': 'rewardActionId', 'type': 'str'},
    }

    def __init__(self, **kwargs) -> None:
        super(RankResponse, self).__init__(**kwargs)
        self.ranking = None
        self.event_id = None
        self.reward_action_id = None


class RewardRequest(Model):
    """Reward given to a rank response.

    All required parameters must be populated in order to send to Azure.

    :param value: Required. Reward to be assigned to an action. Value is a
     float calculated by your application, typically between 0 and 1, and must
     be between -1 and 1.
    :type value: float
    """

    _validation = {
        'value': {'required': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': 'float'},
    }

    def __init__(self, *, value: float, **kwargs) -> None:
        super(RewardRequest, self).__init__(**kwargs)
        self.value = value


class ServiceConfiguration(Model):
    """The configuration of the service.

    All required parameters must be populated in order to send to Azure.

    :param reward_wait_time: Required. The time span waited until a request is
     marked with the default reward
     and should be between 5 seconds and 2 days.
     For example, PT5M (5 mins). For information about the time format,
     see http://en.wikipedia.org/wiki/ISO_8601#Durations
    :type reward_wait_time: timedelta
    :param default_reward: Required. The reward given if a reward is not
     received within the specified wait time.
    :type default_reward: float
    :param reward_aggregation: Required. The function used to process rewards,
     if multiple reward scores are received before rewardWaitTime is over.
    :type reward_aggregation: str
    :param exploration_percentage: Required. The percentage of rank responses
     that will use exploration.
    :type exploration_percentage: float
    :param model_export_frequency: Required. Personalizer will start using the
     most updated trained model for online ranks automatically every specified
     time period.
     For example, PT5M (5 mins). For information about the time format,
     see http://en.wikipedia.org/wiki/ISO_8601#Durations
    :type model_export_frequency: timedelta
    :param log_mirror_enabled: Flag indicates whether log mirroring is
     enabled.
    :type log_mirror_enabled: bool
    :param log_mirror_sas_uri: Azure storage account container SAS URI for log
     mirroring.
    :type log_mirror_sas_uri: str
    :param log_retention_days: Required. Number of days historical logs are to
     be maintained. -1 implies the logs will never be deleted.
    :type log_retention_days: int
    :param last_configuration_edit_date: Last time model training
     configuration was updated
    :type last_configuration_edit_date: datetime
    :param learning_mode: Learning Modes for Personalizer. Possible values
     include: 'Online', 'Apprentice', 'LoggingOnly'
    :type learning_mode: str or
     ~azure.cognitiveservices.personalizer.models.LearningMode
    :param latest_apprentice_mode_metrics:
    :type latest_apprentice_mode_metrics:
     ~azure.cognitiveservices.personalizer.models.ApprenticeModeMetrics
    :param is_auto_optimization_enabled: Flag indicating whether Personalizer
     will automatically optimize Learning Settings by running Offline
     Evaluations periodically.
    :type is_auto_optimization_enabled: bool
    :param auto_optimization_frequency: Frequency of automatic optimization.
     Only relevant if IsAutoOptimizationEnabled is true.
     For example, PT5M (5 mins). For information about the time format,
     \\r\\nsee http://en.wikipedia.org/wiki/ISO_8601#Durations
    :type auto_optimization_frequency: timedelta
    :param auto_optimization_start_date: Date when the first automatic
     optimization evaluation must be performed. Only relevant if
     IsAutoOptimizationEnabled is true.
    :type auto_optimization_start_date: datetime
    """

    _validation = {
        'reward_wait_time': {'required': True},
        'default_reward': {'required': True, 'maximum': 1, 'minimum': -1},
        'reward_aggregation': {'required': True, 'max_length': 256},
        'exploration_percentage': {'required': True, 'maximum': 1, 'minimum': 0},
        'model_export_frequency': {'required': True},
        'log_retention_days': {'required': True, 'maximum': 2147483647, 'minimum': -1},
    }

    _attribute_map = {
        'reward_wait_time': {'key': 'rewardWaitTime', 'type': 'duration'},
        'default_reward': {'key': 'defaultReward', 'type': 'float'},
        'reward_aggregation': {'key': 'rewardAggregation', 'type': 'str'},
        'exploration_percentage': {'key': 'explorationPercentage', 'type': 'float'},
        'model_export_frequency': {'key': 'modelExportFrequency', 'type': 'duration'},
        'log_mirror_enabled': {'key': 'logMirrorEnabled', 'type': 'bool'},
        'log_mirror_sas_uri': {'key': 'logMirrorSasUri', 'type': 'str'},
        'log_retention_days': {'key': 'logRetentionDays', 'type': 'int'},
        'last_configuration_edit_date': {'key': 'lastConfigurationEditDate', 'type': 'iso-8601'},
        'learning_mode': {'key': 'learningMode', 'type': 'str'},
        'latest_apprentice_mode_metrics': {'key': 'latestApprenticeModeMetrics', 'type': 'ApprenticeModeMetrics'},
        'is_auto_optimization_enabled': {'key': 'isAutoOptimizationEnabled', 'type': 'bool'},
        'auto_optimization_frequency': {'key': 'autoOptimizationFrequency', 'type': 'duration'},
        'auto_optimization_start_date': {'key': 'autoOptimizationStartDate', 'type': 'iso-8601'},
    }

    def __init__(self, *, reward_wait_time, default_reward: float, reward_aggregation: str, exploration_percentage: float, model_export_frequency, log_retention_days: int, log_mirror_enabled: bool=None, log_mirror_sas_uri: str=None, last_configuration_edit_date=None, learning_mode=None, latest_apprentice_mode_metrics=None, is_auto_optimization_enabled: bool=None, auto_optimization_frequency=None, auto_optimization_start_date=None, **kwargs) -> None:
        super(ServiceConfiguration, self).__init__(**kwargs)
        self.reward_wait_time = reward_wait_time
        self.default_reward = default_reward
        self.reward_aggregation = reward_aggregation
        self.exploration_percentage = exploration_percentage
        self.model_export_frequency = model_export_frequency
        self.log_mirror_enabled = log_mirror_enabled
        self.log_mirror_sas_uri = log_mirror_sas_uri
        self.log_retention_days = log_retention_days
        self.last_configuration_edit_date = last_configuration_edit_date
        self.learning_mode = learning_mode
        self.latest_apprentice_mode_metrics = latest_apprentice_mode_metrics
        self.is_auto_optimization_enabled = is_auto_optimization_enabled
        self.auto_optimization_frequency = auto_optimization_frequency
        self.auto_optimization_start_date = auto_optimization_start_date


class ServiceStatus(Model):
    """ServiceStatus.

    :param service:
    :type service: str
    :param api_status:
    :type api_status: str
    :param api_status_message:
    :type api_status_message: str
    """

    _attribute_map = {
        'service': {'key': 'service', 'type': 'str'},
        'api_status': {'key': 'apiStatus', 'type': 'str'},
        'api_status_message': {'key': 'apiStatusMessage', 'type': 'str'},
    }

    def __init__(self, *, service: str=None, api_status: str=None, api_status_message: str=None, **kwargs) -> None:
        super(ServiceStatus, self).__init__(**kwargs)
        self.service = service
        self.api_status = api_status
        self.api_status_message = api_status_message


class SlotRequest(Model):
    """A slot with it's associated features and list of excluded actions.

    All required parameters must be populated in order to send to Azure.

    :param id: Required. Slot ID
    :type id: str
    :param features: List of dictionaries containing slot features.
    :type features: list[object]
    :param excluded_actions: List of excluded action Ids.
    :type excluded_actions: list[str]
    :param baseline_action: Required. The 'baseline action' ID for the slot.
     The BaselineAction is the Id of the Action your application would use in
     that slot if Personalizer didn't exist.
     BaselineAction must be defined for every slot.
     BaselineAction should never be part of ExcludedActions.
     Each slot must have a unique BaselineAction which corresponds to an an
     action from the event's Actions list.
    :type baseline_action: str
    """

    _validation = {
        'id': {'required': True},
        'baseline_action': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'features': {'key': 'features', 'type': '[object]'},
        'excluded_actions': {'key': 'excludedActions', 'type': '[str]'},
        'baseline_action': {'key': 'baselineAction', 'type': 'str'},
    }

    def __init__(self, *, id: str, baseline_action: str, features=None, excluded_actions=None, **kwargs) -> None:
        super(SlotRequest, self).__init__(**kwargs)
        self.id = id
        self.features = features
        self.excluded_actions = excluded_actions
        self.baseline_action = baseline_action


class SlotResponse(Model):
    """SlotResponse.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :param id: Required. Id is the slot ID.
    :type id: str
    :ivar reward_action_id: RewardActionID is the action ID recommended by
     Personalizer.
    :vartype reward_action_id: str
    """

    _validation = {
        'id': {'required': True, 'max_length': 256},
        'reward_action_id': {'readonly': True, 'max_length': 256},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'reward_action_id': {'key': 'rewardActionId', 'type': 'str'},
    }

    def __init__(self, *, id: str, **kwargs) -> None:
        super(SlotResponse, self).__init__(**kwargs)
        self.id = id
        self.reward_action_id = None


class SlotReward(Model):
    """SlotReward.

    All required parameters must be populated in order to send to Azure.

    :param slot_id: Required. Slot id for which we are sending the reward.
    :type slot_id: str
    :param value: Required. Reward to be assigned to slotId. Value should be
     between -1 and 1 inclusive.
    :type value: float
    """

    _validation = {
        'slot_id': {'required': True, 'max_length': 256, 'min_length': 1},
        'value': {'required': True},
    }

    _attribute_map = {
        'slot_id': {'key': 'slotId', 'type': 'str'},
        'value': {'key': 'value', 'type': 'float'},
    }

    def __init__(self, *, slot_id: str, value: float, **kwargs) -> None:
        super(SlotReward, self).__init__(**kwargs)
        self.slot_id = slot_id
        self.value = value
