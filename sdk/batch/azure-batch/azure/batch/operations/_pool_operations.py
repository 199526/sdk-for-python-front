# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
import sys
from typing import Any, Callable, Dict, Iterable, Optional, TypeVar, cast

from msrest import Serializer

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict

from .._vendor import _format_url_section
if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore
JSON = MutableMapping[str, Any] # pylint: disable=unsubscriptable-object
T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False

def build_list_usage_metrics_request(
    *,
    start_time: Optional[datetime.datetime] = None,
    end_time: Optional[datetime.datetime] = None,
    filter: Optional[str] = None,
    max_results: Optional[int] = 1000,
    timeout: Optional[int] = 30,
    client_request_id: Optional[str] = None,
    return_client_request_id: Optional[bool] = False,
    ocp_date: Optional[datetime.datetime] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-01-01.15.0"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/poolusagemetrics"

    # Construct parameters
    if start_time is not None:
        _params['starttime'] = _SERIALIZER.query("start_time", start_time, 'iso-8601')
    if end_time is not None:
        _params['endtime'] = _SERIALIZER.query("end_time", end_time, 'iso-8601')
    if filter is not None:
        _params['$filter'] = _SERIALIZER.query("filter", filter, 'str')
    if max_results is not None:
        _params['maxresults'] = _SERIALIZER.query("max_results", max_results, 'int', maximum=1000, minimum=1)
    if timeout is not None:
        _params['timeout'] = _SERIALIZER.query("timeout", timeout, 'int')
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    if client_request_id is not None:
        _headers['client-request-id'] = _SERIALIZER.header("client_request_id", client_request_id, 'str')
    if return_client_request_id is not None:
        _headers['return-client-request-id'] = _SERIALIZER.header("return_client_request_id", return_client_request_id, 'bool')
    if ocp_date is not None:
        _headers['ocp-date'] = _SERIALIZER.header("ocp_date", ocp_date, 'rfc-1123')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_get_all_lifetime_statistics_request(
    *,
    timeout: Optional[int] = 30,
    client_request_id: Optional[str] = None,
    return_client_request_id: Optional[bool] = False,
    ocp_date: Optional[datetime.datetime] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-01-01.15.0"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/lifetimepoolstats"

    # Construct parameters
    if timeout is not None:
        _params['timeout'] = _SERIALIZER.query("timeout", timeout, 'int')
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    if client_request_id is not None:
        _headers['client-request-id'] = _SERIALIZER.header("client_request_id", client_request_id, 'str')
    if return_client_request_id is not None:
        _headers['return-client-request-id'] = _SERIALIZER.header("return_client_request_id", return_client_request_id, 'bool')
    if ocp_date is not None:
        _headers['ocp-date'] = _SERIALIZER.header("ocp_date", ocp_date, 'rfc-1123')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_add_request(
    *,
    json: Optional[JSON] = None,
    content: Any = None,
    timeout: Optional[int] = 30,
    client_request_id: Optional[str] = None,
    return_client_request_id: Optional[bool] = False,
    ocp_date: Optional[datetime.datetime] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-01-01.15.0"))  # type: str
    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))  # type: Optional[str]
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/pools"

    # Construct parameters
    if timeout is not None:
        _params['timeout'] = _SERIALIZER.query("timeout", timeout, 'int')
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    if client_request_id is not None:
        _headers['client-request-id'] = _SERIALIZER.header("client_request_id", client_request_id, 'str')
    if return_client_request_id is not None:
        _headers['return-client-request-id'] = _SERIALIZER.header("return_client_request_id", return_client_request_id, 'bool')
    if ocp_date is not None:
        _headers['ocp-date'] = _SERIALIZER.header("ocp_date", ocp_date, 'rfc-1123')
    if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        params=_params,
        headers=_headers,
        json=json,
        content=content,
        **kwargs
    )


def build_list_request(
    *,
    filter: Optional[str] = None,
    select: Optional[str] = None,
    expand: Optional[str] = None,
    max_results: Optional[int] = 1000,
    timeout: Optional[int] = 30,
    client_request_id: Optional[str] = None,
    return_client_request_id: Optional[bool] = False,
    ocp_date: Optional[datetime.datetime] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-01-01.15.0"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/pools"

    # Construct parameters
    if filter is not None:
        _params['$filter'] = _SERIALIZER.query("filter", filter, 'str')
    if select is not None:
        _params['$select'] = _SERIALIZER.query("select", select, 'str')
    if expand is not None:
        _params['$expand'] = _SERIALIZER.query("expand", expand, 'str')
    if max_results is not None:
        _params['maxresults'] = _SERIALIZER.query("max_results", max_results, 'int', maximum=1000, minimum=1)
    if timeout is not None:
        _params['timeout'] = _SERIALIZER.query("timeout", timeout, 'int')
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    if client_request_id is not None:
        _headers['client-request-id'] = _SERIALIZER.header("client_request_id", client_request_id, 'str')
    if return_client_request_id is not None:
        _headers['return-client-request-id'] = _SERIALIZER.header("return_client_request_id", return_client_request_id, 'bool')
    if ocp_date is not None:
        _headers['ocp-date'] = _SERIALIZER.header("ocp_date", ocp_date, 'rfc-1123')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_delete_request(
    pool_id: str,
    *,
    timeout: Optional[int] = 30,
    client_request_id: Optional[str] = None,
    return_client_request_id: Optional[bool] = False,
    ocp_date: Optional[datetime.datetime] = None,
    if_match: Optional[str] = None,
    if_none_match: Optional[str] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-01-01.15.0"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/pools/{poolId}"
    path_format_arguments = {
        "poolId": _SERIALIZER.url("pool_id", pool_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if timeout is not None:
        _params['timeout'] = _SERIALIZER.query("timeout", timeout, 'int')
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    if client_request_id is not None:
        _headers['client-request-id'] = _SERIALIZER.header("client_request_id", client_request_id, 'str')
    if return_client_request_id is not None:
        _headers['return-client-request-id'] = _SERIALIZER.header("return_client_request_id", return_client_request_id, 'bool')
    if ocp_date is not None:
        _headers['ocp-date'] = _SERIALIZER.header("ocp_date", ocp_date, 'rfc-1123')
    if if_match is not None:
        _headers['If-Match'] = _SERIALIZER.header("if_match", if_match, 'str')
    if if_none_match is not None:
        _headers['If-None-Match'] = _SERIALIZER.header("if_none_match", if_none_match, 'str')
    if if_modified_since is not None:
        _headers['If-Modified-Since'] = _SERIALIZER.header("if_modified_since", if_modified_since, 'rfc-1123')
    if if_unmodified_since is not None:
        _headers['If-Unmodified-Since'] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, 'rfc-1123')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_exists_request(
    pool_id: str,
    *,
    timeout: Optional[int] = 30,
    client_request_id: Optional[str] = None,
    return_client_request_id: Optional[bool] = False,
    ocp_date: Optional[datetime.datetime] = None,
    if_match: Optional[str] = None,
    if_none_match: Optional[str] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-01-01.15.0"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/pools/{poolId}"
    path_format_arguments = {
        "poolId": _SERIALIZER.url("pool_id", pool_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if timeout is not None:
        _params['timeout'] = _SERIALIZER.query("timeout", timeout, 'int')
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    if client_request_id is not None:
        _headers['client-request-id'] = _SERIALIZER.header("client_request_id", client_request_id, 'str')
    if return_client_request_id is not None:
        _headers['return-client-request-id'] = _SERIALIZER.header("return_client_request_id", return_client_request_id, 'bool')
    if ocp_date is not None:
        _headers['ocp-date'] = _SERIALIZER.header("ocp_date", ocp_date, 'rfc-1123')
    if if_match is not None:
        _headers['If-Match'] = _SERIALIZER.header("if_match", if_match, 'str')
    if if_none_match is not None:
        _headers['If-None-Match'] = _SERIALIZER.header("if_none_match", if_none_match, 'str')
    if if_modified_since is not None:
        _headers['If-Modified-Since'] = _SERIALIZER.header("if_modified_since", if_modified_since, 'rfc-1123')
    if if_unmodified_since is not None:
        _headers['If-Unmodified-Since'] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, 'rfc-1123')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="HEAD",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_get_request(
    pool_id: str,
    *,
    select: Optional[str] = None,
    expand: Optional[str] = None,
    timeout: Optional[int] = 30,
    client_request_id: Optional[str] = None,
    return_client_request_id: Optional[bool] = False,
    ocp_date: Optional[datetime.datetime] = None,
    if_match: Optional[str] = None,
    if_none_match: Optional[str] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-01-01.15.0"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/pools/{poolId}"
    path_format_arguments = {
        "poolId": _SERIALIZER.url("pool_id", pool_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if select is not None:
        _params['$select'] = _SERIALIZER.query("select", select, 'str')
    if expand is not None:
        _params['$expand'] = _SERIALIZER.query("expand", expand, 'str')
    if timeout is not None:
        _params['timeout'] = _SERIALIZER.query("timeout", timeout, 'int')
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    if client_request_id is not None:
        _headers['client-request-id'] = _SERIALIZER.header("client_request_id", client_request_id, 'str')
    if return_client_request_id is not None:
        _headers['return-client-request-id'] = _SERIALIZER.header("return_client_request_id", return_client_request_id, 'bool')
    if ocp_date is not None:
        _headers['ocp-date'] = _SERIALIZER.header("ocp_date", ocp_date, 'rfc-1123')
    if if_match is not None:
        _headers['If-Match'] = _SERIALIZER.header("if_match", if_match, 'str')
    if if_none_match is not None:
        _headers['If-None-Match'] = _SERIALIZER.header("if_none_match", if_none_match, 'str')
    if if_modified_since is not None:
        _headers['If-Modified-Since'] = _SERIALIZER.header("if_modified_since", if_modified_since, 'rfc-1123')
    if if_unmodified_since is not None:
        _headers['If-Unmodified-Since'] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, 'rfc-1123')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_patch_request(
    pool_id: str,
    *,
    json: Optional[JSON] = None,
    content: Any = None,
    timeout: Optional[int] = 30,
    client_request_id: Optional[str] = None,
    return_client_request_id: Optional[bool] = False,
    ocp_date: Optional[datetime.datetime] = None,
    if_match: Optional[str] = None,
    if_none_match: Optional[str] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-01-01.15.0"))  # type: str
    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))  # type: Optional[str]
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/pools/{poolId}"
    path_format_arguments = {
        "poolId": _SERIALIZER.url("pool_id", pool_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if timeout is not None:
        _params['timeout'] = _SERIALIZER.query("timeout", timeout, 'int')
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    if client_request_id is not None:
        _headers['client-request-id'] = _SERIALIZER.header("client_request_id", client_request_id, 'str')
    if return_client_request_id is not None:
        _headers['return-client-request-id'] = _SERIALIZER.header("return_client_request_id", return_client_request_id, 'bool')
    if ocp_date is not None:
        _headers['ocp-date'] = _SERIALIZER.header("ocp_date", ocp_date, 'rfc-1123')
    if if_match is not None:
        _headers['If-Match'] = _SERIALIZER.header("if_match", if_match, 'str')
    if if_none_match is not None:
        _headers['If-None-Match'] = _SERIALIZER.header("if_none_match", if_none_match, 'str')
    if if_modified_since is not None:
        _headers['If-Modified-Since'] = _SERIALIZER.header("if_modified_since", if_modified_since, 'rfc-1123')
    if if_unmodified_since is not None:
        _headers['If-Unmodified-Since'] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, 'rfc-1123')
    if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PATCH",
        url=_url,
        params=_params,
        headers=_headers,
        json=json,
        content=content,
        **kwargs
    )


def build_disable_auto_scale_request(
    pool_id: str,
    *,
    timeout: Optional[int] = 30,
    client_request_id: Optional[str] = None,
    return_client_request_id: Optional[bool] = False,
    ocp_date: Optional[datetime.datetime] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-01-01.15.0"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/pools/{poolId}/disableautoscale"
    path_format_arguments = {
        "poolId": _SERIALIZER.url("pool_id", pool_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if timeout is not None:
        _params['timeout'] = _SERIALIZER.query("timeout", timeout, 'int')
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    if client_request_id is not None:
        _headers['client-request-id'] = _SERIALIZER.header("client_request_id", client_request_id, 'str')
    if return_client_request_id is not None:
        _headers['return-client-request-id'] = _SERIALIZER.header("return_client_request_id", return_client_request_id, 'bool')
    if ocp_date is not None:
        _headers['ocp-date'] = _SERIALIZER.header("ocp_date", ocp_date, 'rfc-1123')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_enable_auto_scale_request(
    pool_id: str,
    *,
    json: Optional[JSON] = None,
    content: Any = None,
    timeout: Optional[int] = 30,
    client_request_id: Optional[str] = None,
    return_client_request_id: Optional[bool] = False,
    ocp_date: Optional[datetime.datetime] = None,
    if_match: Optional[str] = None,
    if_none_match: Optional[str] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-01-01.15.0"))  # type: str
    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))  # type: Optional[str]
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/pools/{poolId}/enableautoscale"
    path_format_arguments = {
        "poolId": _SERIALIZER.url("pool_id", pool_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if timeout is not None:
        _params['timeout'] = _SERIALIZER.query("timeout", timeout, 'int')
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    if client_request_id is not None:
        _headers['client-request-id'] = _SERIALIZER.header("client_request_id", client_request_id, 'str')
    if return_client_request_id is not None:
        _headers['return-client-request-id'] = _SERIALIZER.header("return_client_request_id", return_client_request_id, 'bool')
    if ocp_date is not None:
        _headers['ocp-date'] = _SERIALIZER.header("ocp_date", ocp_date, 'rfc-1123')
    if if_match is not None:
        _headers['If-Match'] = _SERIALIZER.header("if_match", if_match, 'str')
    if if_none_match is not None:
        _headers['If-None-Match'] = _SERIALIZER.header("if_none_match", if_none_match, 'str')
    if if_modified_since is not None:
        _headers['If-Modified-Since'] = _SERIALIZER.header("if_modified_since", if_modified_since, 'rfc-1123')
    if if_unmodified_since is not None:
        _headers['If-Unmodified-Since'] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, 'rfc-1123')
    if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        params=_params,
        headers=_headers,
        json=json,
        content=content,
        **kwargs
    )


def build_evaluate_auto_scale_request(
    pool_id: str,
    *,
    json: Optional[JSON] = None,
    content: Any = None,
    timeout: Optional[int] = 30,
    client_request_id: Optional[str] = None,
    return_client_request_id: Optional[bool] = False,
    ocp_date: Optional[datetime.datetime] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-01-01.15.0"))  # type: str
    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))  # type: Optional[str]
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/pools/{poolId}/evaluateautoscale"
    path_format_arguments = {
        "poolId": _SERIALIZER.url("pool_id", pool_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if timeout is not None:
        _params['timeout'] = _SERIALIZER.query("timeout", timeout, 'int')
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    if client_request_id is not None:
        _headers['client-request-id'] = _SERIALIZER.header("client_request_id", client_request_id, 'str')
    if return_client_request_id is not None:
        _headers['return-client-request-id'] = _SERIALIZER.header("return_client_request_id", return_client_request_id, 'bool')
    if ocp_date is not None:
        _headers['ocp-date'] = _SERIALIZER.header("ocp_date", ocp_date, 'rfc-1123')
    if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        params=_params,
        headers=_headers,
        json=json,
        content=content,
        **kwargs
    )


def build_resize_request(
    pool_id: str,
    *,
    json: Optional[JSON] = None,
    content: Any = None,
    timeout: Optional[int] = 30,
    client_request_id: Optional[str] = None,
    return_client_request_id: Optional[bool] = False,
    ocp_date: Optional[datetime.datetime] = None,
    if_match: Optional[str] = None,
    if_none_match: Optional[str] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-01-01.15.0"))  # type: str
    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))  # type: Optional[str]
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/pools/{poolId}/resize"
    path_format_arguments = {
        "poolId": _SERIALIZER.url("pool_id", pool_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if timeout is not None:
        _params['timeout'] = _SERIALIZER.query("timeout", timeout, 'int')
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    if client_request_id is not None:
        _headers['client-request-id'] = _SERIALIZER.header("client_request_id", client_request_id, 'str')
    if return_client_request_id is not None:
        _headers['return-client-request-id'] = _SERIALIZER.header("return_client_request_id", return_client_request_id, 'bool')
    if ocp_date is not None:
        _headers['ocp-date'] = _SERIALIZER.header("ocp_date", ocp_date, 'rfc-1123')
    if if_match is not None:
        _headers['If-Match'] = _SERIALIZER.header("if_match", if_match, 'str')
    if if_none_match is not None:
        _headers['If-None-Match'] = _SERIALIZER.header("if_none_match", if_none_match, 'str')
    if if_modified_since is not None:
        _headers['If-Modified-Since'] = _SERIALIZER.header("if_modified_since", if_modified_since, 'rfc-1123')
    if if_unmodified_since is not None:
        _headers['If-Unmodified-Since'] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, 'rfc-1123')
    if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        params=_params,
        headers=_headers,
        json=json,
        content=content,
        **kwargs
    )


def build_stop_resize_request(
    pool_id: str,
    *,
    timeout: Optional[int] = 30,
    client_request_id: Optional[str] = None,
    return_client_request_id: Optional[bool] = False,
    ocp_date: Optional[datetime.datetime] = None,
    if_match: Optional[str] = None,
    if_none_match: Optional[str] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-01-01.15.0"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/pools/{poolId}/stopresize"
    path_format_arguments = {
        "poolId": _SERIALIZER.url("pool_id", pool_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if timeout is not None:
        _params['timeout'] = _SERIALIZER.query("timeout", timeout, 'int')
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    if client_request_id is not None:
        _headers['client-request-id'] = _SERIALIZER.header("client_request_id", client_request_id, 'str')
    if return_client_request_id is not None:
        _headers['return-client-request-id'] = _SERIALIZER.header("return_client_request_id", return_client_request_id, 'bool')
    if ocp_date is not None:
        _headers['ocp-date'] = _SERIALIZER.header("ocp_date", ocp_date, 'rfc-1123')
    if if_match is not None:
        _headers['If-Match'] = _SERIALIZER.header("if_match", if_match, 'str')
    if if_none_match is not None:
        _headers['If-None-Match'] = _SERIALIZER.header("if_none_match", if_none_match, 'str')
    if if_modified_since is not None:
        _headers['If-Modified-Since'] = _SERIALIZER.header("if_modified_since", if_modified_since, 'rfc-1123')
    if if_unmodified_since is not None:
        _headers['If-Unmodified-Since'] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, 'rfc-1123')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_update_properties_request(
    pool_id: str,
    *,
    json: Optional[JSON] = None,
    content: Any = None,
    timeout: Optional[int] = 30,
    client_request_id: Optional[str] = None,
    return_client_request_id: Optional[bool] = False,
    ocp_date: Optional[datetime.datetime] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-01-01.15.0"))  # type: str
    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))  # type: Optional[str]
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/pools/{poolId}/updateproperties"
    path_format_arguments = {
        "poolId": _SERIALIZER.url("pool_id", pool_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if timeout is not None:
        _params['timeout'] = _SERIALIZER.query("timeout", timeout, 'int')
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    if client_request_id is not None:
        _headers['client-request-id'] = _SERIALIZER.header("client_request_id", client_request_id, 'str')
    if return_client_request_id is not None:
        _headers['return-client-request-id'] = _SERIALIZER.header("return_client_request_id", return_client_request_id, 'bool')
    if ocp_date is not None:
        _headers['ocp-date'] = _SERIALIZER.header("ocp_date", ocp_date, 'rfc-1123')
    if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        params=_params,
        headers=_headers,
        json=json,
        content=content,
        **kwargs
    )


def build_remove_nodes_request(
    pool_id: str,
    *,
    json: Optional[JSON] = None,
    content: Any = None,
    timeout: Optional[int] = 30,
    client_request_id: Optional[str] = None,
    return_client_request_id: Optional[bool] = False,
    ocp_date: Optional[datetime.datetime] = None,
    if_match: Optional[str] = None,
    if_none_match: Optional[str] = None,
    if_modified_since: Optional[datetime.datetime] = None,
    if_unmodified_since: Optional[datetime.datetime] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-01-01.15.0"))  # type: str
    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))  # type: Optional[str]
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/pools/{poolId}/removenodes"
    path_format_arguments = {
        "poolId": _SERIALIZER.url("pool_id", pool_id, 'str'),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if timeout is not None:
        _params['timeout'] = _SERIALIZER.query("timeout", timeout, 'int')
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    if client_request_id is not None:
        _headers['client-request-id'] = _SERIALIZER.header("client_request_id", client_request_id, 'str')
    if return_client_request_id is not None:
        _headers['return-client-request-id'] = _SERIALIZER.header("return_client_request_id", return_client_request_id, 'bool')
    if ocp_date is not None:
        _headers['ocp-date'] = _SERIALIZER.header("ocp_date", ocp_date, 'rfc-1123')
    if if_match is not None:
        _headers['If-Match'] = _SERIALIZER.header("if_match", if_match, 'str')
    if if_none_match is not None:
        _headers['If-None-Match'] = _SERIALIZER.header("if_none_match", if_none_match, 'str')
    if if_modified_since is not None:
        _headers['If-Modified-Since'] = _SERIALIZER.header("if_modified_since", if_modified_since, 'rfc-1123')
    if if_unmodified_since is not None:
        _headers['If-Unmodified-Since'] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, 'rfc-1123')
    if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        params=_params,
        headers=_headers,
        json=json,
        content=content,
        **kwargs
    )

class PoolOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure-batch.BatchServiceClient`'s
        :attr:`pool` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")


    @distributed_trace
    def list_usage_metrics(
        self,
        *,
        start_time: Optional[datetime.datetime] = None,
        end_time: Optional[datetime.datetime] = None,
        filter: Optional[str] = None,
        max_results: Optional[int] = 1000,
        timeout: Optional[int] = 30,
        client_request_id: Optional[str] = None,
        return_client_request_id: Optional[bool] = False,
        ocp_date: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Lists the usage metrics, aggregated by Pool across individual time intervals, for the specified
        Account.

        If you do not specify a $filter clause including a poolId, the response includes all Pools that
        existed in the Account in the time range of the returned aggregation intervals. If you do not
        specify a $filter clause including a startTime or endTime these filters default to the start
        and end times of the last aggregation interval currently available; that is, only the last
        aggregation interval is returned.

        :keyword start_time: The earliest time from which to include metrics. This must be at least two
         and a half hours before the current time. If not specified this defaults to the start time of
         the last aggregation interval currently available. Default value is None.
        :paramtype start_time: ~datetime.datetime
        :keyword end_time: The latest time from which to include metrics. This must be at least two
         hours before the current time. If not specified this defaults to the end time of the last
         aggregation interval currently available. Default value is None.
        :paramtype end_time: ~datetime.datetime
        :keyword filter: An OData $filter clause. For more information on constructing this filter, see
         https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-account-usage-metrics.
         Default value is None.
        :paramtype filter: str
        :keyword max_results: The maximum number of items to return in the response. A maximum of 1000
         results will be returned. Default value is 1000.
        :paramtype max_results: int
        :keyword timeout: The maximum time that the server can spend processing the request, in
         seconds. The default is 30 seconds.
        :paramtype timeout: int
        :keyword client_request_id: The caller-generated request identity, in the form of a GUID with
         no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. Default value is
         None.
        :paramtype client_request_id: str
        :keyword return_client_request_id: Whether the server should return the client-request-id in
         the response. Default value is False.
        :paramtype return_client_request_id: bool
        :keyword ocp_date: The time the request was issued. Client libraries typically set this to the
         current system clock time; set it explicitly if you are calling the REST API directly. Default
         value is None.
        :paramtype ocp_date: ~datetime.datetime
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "odata.nextLink": "str",  # Optional. The URL to get the next set of results.
                    "value": [
                        {
                            "endTime": "2020-02-20 00:00:00",  # Required. The end time
                              of the aggregation interval covered by this entry.
                            "poolId": "str",  # Required. The ID of the Pool whose
                              metrics are aggregated in this entry.
                            "startTime": "2020-02-20 00:00:00",  # Required. The start
                              time of the aggregation interval covered by this entry.
                            "totalCoreHours": 0.0,  # Required. The total core hours used
                              in the Pool during this aggregation interval.
                            "vmSize": "str"  # Required. For information about available
                              sizes of virtual machines in Pools, see Choose a VM size for Compute
                              Nodes in an Azure Batch Pool
                              (https://docs.microsoft.com/azure/batch/batch-pool-vm-sizes).
                        }
                    ]
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-01-01.15.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_list_usage_metrics_request(
                    api_version=api_version,
                    start_time=start_time,
                    end_time=end_time,
                    filter=filter,
                    max_results=max_results,
                    timeout=timeout,
                    client_request_id=client_request_id,
                    return_client_request_id=return_client_request_id,
                    ocp_date=ocp_date,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "batchUrl": self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                
                request = build_list_usage_metrics_request(
                    client_request_id=client_request_id,
                    return_client_request_id=return_client_request_id,
                    ocp_date=ocp_date,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "batchUrl": self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(next_link, **path_format_arguments)  # type: ignore

                path_format_arguments = {
                    "batchUrl": self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("odata.nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
                request,
                stream=False,
                **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )


    @distributed_trace
    def get_all_lifetime_statistics(
        self,
        *,
        timeout: Optional[int] = 30,
        client_request_id: Optional[str] = None,
        return_client_request_id: Optional[bool] = False,
        ocp_date: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> JSON:
        """Gets lifetime summary statistics for all of the Pools in the specified Account.

        Statistics are aggregated across all Pools that have ever existed in the Account, from Account
        creation to the last update time of the statistics. The statistics may not be immediately
        available. The Batch service performs periodic roll-up of statistics. The typical delay is
        about 30 minutes.

        :keyword timeout: The maximum time that the server can spend processing the request, in
         seconds. The default is 30 seconds.
        :paramtype timeout: int
        :keyword client_request_id: The caller-generated request identity, in the form of a GUID with
         no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. Default value is
         None.
        :paramtype client_request_id: str
        :keyword return_client_request_id: Whether the server should return the client-request-id in
         the response. Default value is False.
        :paramtype return_client_request_id: bool
        :keyword ocp_date: The time the request was issued. Client libraries typically set this to the
         current system clock time; set it explicitly if you are calling the REST API directly. Default
         value is None.
        :paramtype ocp_date: ~datetime.datetime
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "lastUpdateTime": "2020-02-20 00:00:00",  # Required. The time at which the
                      statistics were last updated. All statistics are limited to the range between
                      startTime and lastUpdateTime.
                    "resourceStats": {
                        "avgCPUPercentage": 0.0,  # Required. The average CPU usage across
                          all Compute Nodes in the Pool (percentage per node).
                        "avgDiskGiB": 0.0,  # Required. The average used disk space in GiB
                          across all Compute Nodes in the Pool.
                        "avgMemoryGiB": 0.0,  # Required. The average memory usage in GiB
                          across all Compute Nodes in the Pool.
                        "diskReadGiB": 0.0,  # Required. The total amount of data in GiB of
                          disk reads across all Compute Nodes in the Pool.
                        "diskReadIOps": 0.0,  # Required. The total number of disk read
                          operations across all Compute Nodes in the Pool.
                        "diskWriteGiB": 0.0,  # Required. The total amount of data in GiB of
                          disk writes across all Compute Nodes in the Pool.
                        "diskWriteIOps": 0.0,  # Required. The total number of disk write
                          operations across all Compute Nodes in the Pool.
                        "lastUpdateTime": "2020-02-20 00:00:00",  # Required. The time at
                          which the statistics were last updated. All statistics are limited to the
                          range between startTime and lastUpdateTime.
                        "networkReadGiB": 0.0,  # Required. The total amount of data in GiB
                          of network reads across all Compute Nodes in the Pool.
                        "networkWriteGiB": 0.0,  # Required. The total amount of data in GiB
                          of network writes across all Compute Nodes in the Pool.
                        "peakDiskGiB": 0.0,  # Required. The peak used disk space in GiB
                          across all Compute Nodes in the Pool.
                        "peakMemoryGiB": 0.0,  # Required. The peak memory usage in GiB
                          across all Compute Nodes in the Pool.
                        "startTime": "2020-02-20 00:00:00"  # Required. The start time of the
                          time range covered by the statistics.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Required. The start time of the time
                      range covered by the statistics.
                    "url": "str",  # Required. The URL for the statistics.
                    "usageStats": {
                        "dedicatedCoreTime": "1 day, 0:00:00",  # Required. The aggregated
                          wall-clock time of the dedicated Compute Node cores being part of the Pool.
                        "lastUpdateTime": "2020-02-20 00:00:00",  # Required. The time at
                          which the statistics were last updated. All statistics are limited to the
                          range between startTime and lastUpdateTime.
                        "startTime": "2020-02-20 00:00:00"  # Required. The start time of the
                          time range covered by the statistics.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-01-01.15.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_all_lifetime_statistics_request(
            api_version=api_version,
            timeout=timeout,
            client_request_id=client_request_id,
            return_client_request_id=return_client_request_id,
            ocp_date=ocp_date,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "batchUrl": self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['client-request-id']=self._deserialize('str', response.headers.get('client-request-id'))
        response_headers['request-id']=self._deserialize('str', response.headers.get('request-id'))
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)

        return cast(JSON, deserialized)



    @distributed_trace
    def add(  # pylint: disable=inconsistent-return-statements
        self,
        pool: JSON,
        *,
        timeout: Optional[int] = 30,
        client_request_id: Optional[str] = None,
        return_client_request_id: Optional[bool] = False,
        ocp_date: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> None:
        """Adds a Pool to the specified Account.

        When naming Pools, avoid including sensitive information such as user names or secret project
        names. This information may appear in telemetry logs accessible to Microsoft Support engineers.

        :param pool: The Pool to be added.
        :type pool: JSON
        :keyword timeout: The maximum time that the server can spend processing the request, in
         seconds. The default is 30 seconds.
        :paramtype timeout: int
        :keyword client_request_id: The caller-generated request identity, in the form of a GUID with
         no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. Default value is
         None.
        :paramtype client_request_id: str
        :keyword return_client_request_id: Whether the server should return the client-request-id in
         the response. Default value is False.
        :paramtype return_client_request_id: bool
        :keyword ocp_date: The time the request was issued. Client libraries typically set this to the
         current system clock time; set it explicitly if you are calling the REST API directly. Default
         value is None.
        :paramtype ocp_date: ~datetime.datetime
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                pool = {
                    "applicationLicenses": [
                        "str"  # Optional. The list of application licenses must be a subset
                          of available Batch service application licenses. If a license is requested
                          which is not supported, Pool creation will fail.
                    ],
                    "applicationPackageReferences": [
                        {
                            "applicationId": "str",  # Required. The ID of the
                              application to deploy.
                            "version": "str"  # Optional. If this is omitted on a Pool,
                              and no default version is specified for this application, the request
                              fails with the error code InvalidApplicationPackageReferences and HTTP
                              status code 409. If this is omitted on a Task, and no default version is
                              specified for this application, the Task fails with a pre-processing
                              error.
                        }
                    ],
                    "autoScaleEvaluationInterval": "1 day, 0:00:00",  # Optional. The default
                      value is 15 minutes. The minimum and maximum value are 5 minutes and 168 hours
                      respectively. If you specify a value less than 5 minutes or greater than 168
                      hours, the Batch service returns an error; if you are calling the REST API
                      directly, the HTTP status code is 400 (Bad Request).
                    "autoScaleFormula": "str",  # Optional. This property must not be specified
                      if enableAutoScale is set to false. It is required if enableAutoScale is set to
                      true. The formula is checked for validity before the Pool is created. If the
                      formula is not valid, the Batch service rejects the request with detailed error
                      information. For more information about specifying this formula, see
                      'Automatically scale Compute Nodes in an Azure Batch Pool'
                      (https://azure.microsoft.com/documentation/articles/batch-automatic-scaling/).
                    "certificateReferences": [
                        {
                            "storeLocation": "str",  # Optional. The default value is
                              currentuser. This property is applicable only for Pools configured with
                              Windows Compute Nodes (that is, created with cloudServiceConfiguration,
                              or with virtualMachineConfiguration using a Windows Image reference). For
                              Linux Compute Nodes, the Certificates are stored in a directory inside
                              the Task working directory and an environment variable
                              AZ_BATCH_CERTIFICATES_DIR is supplied to the Task to query for this
                              location. For Certificates with visibility of 'remoteUser', a 'certs'
                              directory is created in the user's home directory (e.g.,
                              /home/{user-name}/certs) and Certificates are placed in that directory.
                              Known values are: "currentuser", "localmachine".
                            "storeName": "str",  # Optional. This property is applicable
                              only for Pools configured with Windows Compute Nodes (that is, created
                              with cloudServiceConfiguration, or with virtualMachineConfiguration using
                              a Windows Image reference). Common store names include: My, Root, CA,
                              Trust, Disallowed, TrustedPeople, TrustedPublisher, AuthRoot,
                              AddressBook, but any custom store name can also be used. The default
                              value is My.
                            "thumbprint": "str",  # Required. The thumbprint of the
                              Certificate.
                            "thumbprintAlgorithm": "str",  # Required. The algorithm with
                              which the thumbprint is associated. This must be sha1.
                            "visibility": [
                                "str"  # Optional. You can specify more than one
                                  visibility in this collection. The default is all Accounts.
                            ]
                        }
                    ],
                    "cloudServiceConfiguration": {
                        "osFamily": "str",  # Required. Possible values are:"n2 - OS Family
                          2, equivalent to Windows Server 2008 R2 SP1."n3 - OS Family 3, equivalent to
                          Windows Server 2012."n4 - OS Family 4, equivalent to Windows Server 2012
                          R2."n5 - OS Family 5, equivalent to Windows Server 2016."n6 - OS Family 6,
                          equivalent to Windows Server 2019. For more information, see Azure Guest OS
                          Releases
                          (https://azure.microsoft.com/documentation/articles/cloud-services-guestos-update-matrix/#releases).
                        "osVersion": "str"  # Optional. The default value is * which
                          specifies the latest operating system version for the specified OS family.
                    },
                    "displayName": "str",  # Optional. The display name need not be unique and
                      can contain any Unicode characters up to a maximum length of 1024.
                    "enableAutoScale": bool,  # Optional. If false, at least one of
                      targetDedicatedNodes and targetLowPriorityNodes must be specified. If true, the
                      autoScaleFormula property is required and the Pool automatically resizes
                      according to the formula. The default value is false.
                    "enableInterNodeCommunication": bool,  # Optional. Enabling inter-node
                      communication limits the maximum size of the Pool due to deployment restrictions
                      on the Compute Nodes of the Pool. This may result in the Pool not reaching its
                      desired size. The default value is false.
                    "id": "str",  # Required. The ID can contain any combination of alphanumeric
                      characters including hyphens and underscores, and cannot contain more than 64
                      characters. The ID is case-preserving and case-insensitive (that is, you may not
                      have two Pool IDs within an Account that differ only by case).
                    "metadata": [
                        {
                            "name": "str",  # Required. The name of the metadata item.
                            "value": "str"  # Required. The value of the metadata item.
                        }
                    ],
                    "mountConfiguration": [
                        {
                            "azureBlobFileSystemConfiguration": {
                                "accountKey": "str",  # Optional. This property is
                                  mutually exclusive with both sasKey and identity; exactly one must be
                                  specified.
                                "accountName": "str",  # Required. The Azure Storage
                                  Account name.
                                "blobfuseOptions": "str",  # Optional. These are 'net
                                  use' options in Windows and 'mount' options in Linux.
                                "containerName": "str",  # Required. The Azure Blob
                                  Storage Container name.
                                "identityReference": {
                                    "resourceId": "str"  # Optional. The ARM
                                      resource id of the user assigned identity.
                                },
                                "relativeMountPath": "str",  # Required. All file
                                  systems are mounted relative to the Batch mounts directory,
                                  accessible via the AZ_BATCH_NODE_MOUNTS_DIR environment variable.
                                "sasKey": "str"  # Optional. This property is
                                  mutually exclusive with both accountKey and identity; exactly one
                                  must be specified.
                            },
                            "azureFileShareConfiguration": {
                                "accountKey": "str",  # Required. The Azure Storage
                                  account key.
                                "accountName": "str",  # Required. The Azure Storage
                                  account name.
                                "azureFileUrl": "str",  # Required. This is of the
                                  form 'https://{account}.file.core.windows.net/'.
                                "mountOptions": "str",  # Optional. These are 'net
                                  use' options in Windows and 'mount' options in Linux.
                                "relativeMountPath": "str"  # Required. All file
                                  systems are mounted relative to the Batch mounts directory,
                                  accessible via the AZ_BATCH_NODE_MOUNTS_DIR environment variable.
                            },
                            "cifsMountConfiguration": {
                                "mountOptions": "str",  # Optional. These are 'net
                                  use' options in Windows and 'mount' options in Linux.
                                "password": "str",  # Required. The password to use
                                  for authentication against the CIFS file system.
                                "relativeMountPath": "str",  # Required. All file
                                  systems are mounted relative to the Batch mounts directory,
                                  accessible via the AZ_BATCH_NODE_MOUNTS_DIR environment variable.
                                "source": "str",  # Required. The URI of the file
                                  system to mount.
                                "username": "str"  # Required. The user to use for
                                  authentication against the CIFS file system.
                            },
                            "nfsMountConfiguration": {
                                "mountOptions": "str",  # Optional. These are 'net
                                  use' options in Windows and 'mount' options in Linux.
                                "relativeMountPath": "str",  # Required. All file
                                  systems are mounted relative to the Batch mounts directory,
                                  accessible via the AZ_BATCH_NODE_MOUNTS_DIR environment variable.
                                "source": "str"  # Required. The URI of the file
                                  system to mount.
                            }
                        }
                    ],
                    "networkConfiguration": {
                        "dynamicVNetAssignmentScope": "str",  # Optional. The scope of
                          dynamic vnet assignment. Known values are: "none", "job".
                        "endpointConfiguration": {
                            "inboundNATPools": [
                                {
                                    "backendPort": 0,  # Required. This must be
                                      unique within a Batch Pool. Acceptable values are between 1 and
                                      65535 except for 22, 3389, 29876 and 29877 as these are reserved.
                                      If any reserved values are provided the request fails with HTTP
                                      status code 400.
                                    "frontendPortRangeEnd": 0,  # Required.
                                      Acceptable values range between 1 and 65534 except ports from
                                      50000 to 55000 which are reserved by the Batch service. All
                                      ranges within a Pool must be distinct and cannot overlap. Each
                                      range must contain at least 40 ports. If any reserved or
                                      overlapping values are provided the request fails with HTTP
                                      status code 400.
                                    "frontendPortRangeStart": 0,  # Required.
                                      Acceptable values range between 1 and 65534 except ports from
                                      50000 to 55000 which are reserved. All ranges within a Pool must
                                      be distinct and cannot overlap. Each range must contain at least
                                      40 ports. If any reserved or overlapping values are provided the
                                      request fails with HTTP status code 400.
                                    "name": "str",  # Required. The name must be
                                      unique within a Batch Pool, can contain letters, numbers,
                                      underscores, periods, and hyphens. Names must start with a letter
                                      or number, must end with a letter, number, or underscore, and
                                      cannot exceed 77 characters.  If any invalid values are provided
                                      the request fails with HTTP status code 400.
                                    "networkSecurityGroupRules": [
                                        {
                                            "access": "str",  # Required.
                                              The action that should be taken for a specified IP
                                              address, subnet range or tag. Known values are: "allow",
                                              "deny".
                                            "priority": 0,  # Required.
                                              Priorities within a Pool must be unique and are evaluated
                                              in order of priority. The lower the number the higher the
                                              priority. For example, rules could be specified with
                                              order numbers of 150, 250, and 350. The rule with the
                                              order number of 150 takes precedence over the rule that
                                              has an order of 250. Allowed priorities are 150 to 4096.
                                              If any reserved or duplicate values are provided the
                                              request fails with HTTP status code 400.
                                            "sourceAddressPrefix": "str",
                                              # Required. Valid values are a single IP address (i.e.
                                              10.10.10.10), IP subnet (i.e. 192.168.1.0/24), default
                                              tag, or * (for all addresses).  If any other values are
                                              provided the request fails with HTTP status code 400.
                                            "sourcePortRanges": [
                                                "str"  # Optional.
                                                  Valid values are '"" *' (for all ports 0 - 65535), a
                                                  specific port (i.e. 22), or a port range (i.e.
                                                  100-200). The ports must be in the range of 0 to
                                                  65535. Each entry in this collection must not overlap
                                                  any other entry (either a range or an individual
                                                  port). If any other values are provided the request
                                                  fails with HTTP status code 400. The default value is
                                                  '*"" '.
                                            ]
                                        }
                                    ],
                                    "protocol": "str"  # Required. The protocol
                                      of the endpoint. Known values are: "tcp", "udp".
                                }
                            ]
                        },
                        "publicIPAddressConfiguration": {
                            "ipAddressIds": [
                                "str"  # Optional. The number of IPs specified here
                                  limits the maximum size of the Pool - 100 dedicated nodes or 100
                                  Spot/Low-priority nodes can be allocated for each public IP. For
                                  example, a pool needing 250 dedicated VMs would need at least 3
                                  public IPs specified. Each element of this collection is of the form:
                                  /subscriptions/{subscription}/resourceGroups/{group}/providers/Microsoft.Network/publicIPAddresses/{ip}.
                            ],
                            "provision": "str"  # Optional. The default value is
                              BatchManaged. Known values are: "batchmanaged", "usermanaged",
                              "nopublicipaddresses".
                        },
                        "subnetId": "str"  # Optional. The virtual network must be in the
                          same region and subscription as the Azure Batch Account. The specified subnet
                          should have enough free IP addresses to accommodate the number of Compute
                          Nodes in the Pool. If the subnet doesn't have enough free IP addresses, the
                          Pool will partially allocate Nodes and a resize error will occur. The
                          'MicrosoftAzureBatch' service principal must have the 'Classic Virtual
                          Machine Contributor' Role-Based Access Control (RBAC) role for the specified
                          VNet. The specified subnet must allow communication from the Azure Batch
                          service to be able to schedule Tasks on the Nodes. This can be verified by
                          checking if the specified VNet has any associated Network Security Groups
                          (NSG). If communication to the Nodes in the specified subnet is denied by an
                          NSG, then the Batch service will set the state of the Compute Nodes to
                          unusable. For Pools created with virtualMachineConfiguration only ARM virtual
                          networks ('Microsoft.Network/virtualNetworks') are supported, but for Pools
                          created with cloudServiceConfiguration both ARM and classic virtual networks
                          are supported. If the specified VNet has any associated Network Security
                          Groups (NSG), then a few reserved system ports must be enabled for inbound
                          communication. For Pools created with a virtual machine configuration, enable
                          ports 29876 and 29877, as well as port 22 for Linux and port 3389 for
                          Windows. For Pools created with a cloud service configuration, enable ports
                          10100, 20100, and 30100. Also enable outbound connections to Azure Storage on
                          port 443. For more details see:
                          https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration.
                    },
                    "resizeTimeout": "1 day, 0:00:00",  # Optional. This timeout applies only to
                      manual scaling; it has no effect when enableAutoScale is set to true. The default
                      value is 15 minutes. The minimum value is 5 minutes. If you specify a value less
                      than 5 minutes, the Batch service returns an error; if you are calling the REST
                      API directly, the HTTP status code is 400 (Bad Request).
                    "startTask": {
                        "commandLine": "str",  # Required. The command line does not run
                          under a shell, and therefore cannot take advantage of shell features such as
                          environment variable expansion. If you want to take advantage of such
                          features, you should invoke the shell in the command line, for example using
                          "cmd /c MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux. If the
                          command line refers to file paths, it should use a relative path (relative to
                          the Task working directory), or use the Batch provided environment variable
                          (https://docs.microsoft.com/en-us/azure/batch/batch-compute-node-environment-variables).
                        "containerSettings": {
                            "containerRunOptions": "str",  # Optional. These additional
                              options are supplied as arguments to the "docker create" command, in
                              addition to those controlled by the Batch Service.
                            "imageName": "str",  # Required. This is the full Image
                              reference, as would be specified to "docker pull". If no tag is provided
                              as part of the Image name, the tag ":latest" is used as a default.
                            "registry": {
                                "identityReference": {
                                    "resourceId": "str"  # Optional. The ARM
                                      resource id of the user assigned identity.
                                },
                                "password": "str",  # Optional. The password to log
                                  into the registry server.
                                "registryServer": "str",  # Optional. If omitted, the
                                  default is "docker.io".
                                "username": "str"  # Optional. The user name to log
                                  into the registry server.
                            },
                            "workingDirectory": "str"  # Optional. The default is
                              'taskWorkingDirectory'. Known values are: "taskWorkingDirectory",
                              "containerImageDefault".
                        },
                        "environmentSettings": [
                            {
                                "name": "str",  # Required. The name of the
                                  environment variable.
                                "value": "str"  # Optional. The value of the
                                  environment variable.
                            }
                        ],
                        "maxTaskRetryCount": 0,  # Optional. The Batch service retries a Task
                          if its exit code is nonzero. Note that this value specifically controls the
                          number of retries. The Batch service will try the Task once, and may then
                          retry up to this limit. For example, if the maximum retry count is 3, Batch
                          tries the Task up to 4 times (one initial try and 3 retries). If the maximum
                          retry count is 0, the Batch service does not retry the Task. If the maximum
                          retry count is -1, the Batch service retries the Task without limit, however
                          this is not recommended for a start task or any task. The default value is 0
                          (no retries).
                        "resourceFiles": [
                            {
                                "autoStorageContainerName": "str",  # Optional. The
                                  autoStorageContainerName, storageContainerUrl and httpUrl properties
                                  are mutually exclusive and one of them must be specified.
                                "blobPrefix": "str",  # Optional. The property is
                                  valid only when autoStorageContainerName or storageContainerUrl is
                                  used. This prefix can be a partial filename or a subdirectory. If a
                                  prefix is not specified, all the files in the container will be
                                  downloaded.
                                "fileMode": "str",  # Optional. This property applies
                                  only to files being downloaded to Linux Compute Nodes. It will be
                                  ignored if it is specified for a resourceFile which will be
                                  downloaded to a Windows Compute Node. If this property is not
                                  specified for a Linux Compute Node, then a default value of 0770 is
                                  applied to the file.
                                "filePath": "str",  # Optional. If the httpUrl
                                  property is specified, the filePath is required and describes the
                                  path which the file will be downloaded to, including the filename.
                                  Otherwise, if the autoStorageContainerName or storageContainerUrl
                                  property is specified, filePath is optional and is the directory to
                                  download the files to. In the case where filePath is used as a
                                  directory, any directory structure already associated with the input
                                  data will be retained in full and appended to the specified filePath
                                  directory. The specified relative path cannot break out of the Task's
                                  working directory (for example by using '..').
                                "httpUrl": "str",  # Optional. The
                                  autoStorageContainerName, storageContainerUrl and httpUrl properties
                                  are mutually exclusive and one of them must be specified. If the URL
                                  points to Azure Blob Storage, it must be readable from compute nodes.
                                  There are three ways to get such a URL for a blob in Azure storage:
                                  include a Shared Access Signature (SAS) granting read permissions on
                                  the blob, use a managed identity with read permission, or set the ACL
                                  for the blob or its container to allow public access.
                                "identityReference": {
                                    "resourceId": "str"  # Optional. The ARM
                                      resource id of the user assigned identity.
                                },
                                "storageContainerUrl": "str"  # Optional. The
                                  autoStorageContainerName, storageContainerUrl and httpUrl properties
                                  are mutually exclusive and one of them must be specified. This URL
                                  must be readable and listable from compute nodes. There are three
                                  ways to get such a URL for a container in Azure storage: include a
                                  Shared Access Signature (SAS) granting read and list permissions on
                                  the container, use a managed identity with read and list permissions,
                                  or set the ACL for the container to allow public access.
                            }
                        ],
                        "userIdentity": {
                            "autoUser": {
                                "elevationLevel": "str",  # Optional. The default
                                  value is nonAdmin. Known values are: "nonadmin", "admin".
                                "scope": "str"  # Optional. The default value is
                                  pool. If the pool is running Windows a value of Task should be
                                  specified if stricter isolation between tasks is required. For
                                  example, if the task mutates the registry in a way which could impact
                                  other tasks, or if certificates have been specified on the pool which
                                  should not be accessible by normal tasks but should be accessible by
                                  StartTasks. Known values are: "task", "pool".
                            },
                            "username": "str"  # Optional. The userName and autoUser
                              properties are mutually exclusive; you must specify one but not both.
                        },
                        "waitForSuccess": bool  # Optional. If true and the StartTask fails
                          on a Node, the Batch service retries the StartTask up to its maximum retry
                          count (maxTaskRetryCount). If the Task has still not completed successfully
                          after all retries, then the Batch service marks the Node unusable, and will
                          not schedule Tasks to it. This condition can be detected via the Compute Node
                          state and failure info details. If false, the Batch service will not wait for
                          the StartTask to complete. In this case, other Tasks can start executing on
                          the Compute Node while the StartTask is still running; and even if the
                          StartTask fails, new Tasks will continue to be scheduled on the Compute Node.
                          The default is true.
                    },
                    "targetDedicatedNodes": 0,  # Optional. This property must not be specified
                      if enableAutoScale is set to true. If enableAutoScale is set to false, then you
                      must set either targetDedicatedNodes, targetLowPriorityNodes, or both.
                    "targetLowPriorityNodes": 0,  # Optional. This property must not be specified
                      if enableAutoScale is set to true. If enableAutoScale is set to false, then you
                      must set either targetDedicatedNodes, targetLowPriorityNodes, or both.
                    "taskSchedulingPolicy": {
                        "nodeFillType": "str"  # Required. If not specified, the default is
                          spread. Known values are: "spread", "pack".
                    },
                    "taskSlotsPerNode": 0,  # Optional. The default value is 1. The maximum value
                      is the smaller of 4 times the number of cores of the vmSize of the pool or 256.
                    "userAccounts": [
                        {
                            "elevationLevel": "str",  # Optional. The default value is
                              nonAdmin. Known values are: "nonadmin", "admin".
                            "linuxUserConfiguration": {
                                "gid": 0,  # Optional. The uid and gid properties
                                  must be specified together or not at all. If not specified the
                                  underlying operating system picks the gid.
                                "sshPrivateKey": "str",  # Optional. The private key
                                  must not be password protected. The private key is used to
                                  automatically configure asymmetric-key based authentication for SSH
                                  between Compute Nodes in a Linux Pool when the Pool's
                                  enableInterNodeCommunication property is true (it is ignored if
                                  enableInterNodeCommunication is false). It does this by placing the
                                  key pair into the user's .ssh directory. If not specified,
                                  password-less SSH is not configured between Compute Nodes (no
                                  modification of the user's .ssh directory is done).
                                "uid": 0  # Optional. The uid and gid properties must
                                  be specified together or not at all. If not specified the underlying
                                  operating system picks the uid.
                            },
                            "name": "str",  # Required. The name of the user Account.
                            "password": "str",  # Required. The password for the user
                              Account.
                            "windowsUserConfiguration": {
                                "loginMode": "str"  # Optional. The default value for
                                  VirtualMachineConfiguration Pools is 'batch' and for
                                  CloudServiceConfiguration Pools is 'interactive'. Known values are:
                                  "batch", "interactive".
                            }
                        }
                    ],
                    "virtualMachineConfiguration": {
                        "containerConfiguration": {
                            "containerImageNames": [
                                "str"  # Optional. This is the full Image reference,
                                  as would be specified to "docker pull". An Image will be sourced from
                                  the default Docker registry unless the Image is fully qualified with
                                  an alternative registry.
                            ],
                            "containerRegistries": [
                                {
                                    "identityReference": {
                                        "resourceId": "str"  # Optional. The
                                          ARM resource id of the user assigned identity.
                                    },
                                    "password": "str",  # Optional. The password
                                      to log into the registry server.
                                    "registryServer": "str",  # Optional. If
                                      omitted, the default is "docker.io".
                                    "username": "str"  # Optional. The user name
                                      to log into the registry server.
                                }
                            ],
                            "type": "dockerCompatible"  # Default value is
                              "dockerCompatible". The container technology to be used. Has constant
                              value: "dockerCompatible".
                        },
                        "dataDisks": [
                            {
                                "caching": "str",  # Optional. The default value for
                                  caching is readwrite. For information about the caching options see:
                                  https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/27/exploring-windows-azure-drives-disks-and-images/.
                                  Known values are: "none", "readonly", "readwrite".
                                "diskSizeGB": 0,  # Required. The initial disk size
                                  in gigabytes.
                                "lun": 0,  # Required. The lun is used to uniquely
                                  identify each data disk. If attaching multiple disks, each should
                                  have a distinct lun. The value must be between 0 and 63, inclusive.
                                "storageAccountType": "str"  # Optional. If omitted,
                                  the default is "standard_lrs". Known values are: "standard_lrs",
                                  "premium_lrs".
                            }
                        ],
                        "diskEncryptionConfiguration": {
                            "targets": [
                                "str"  # Optional. If omitted, no disks on the
                                  compute nodes in the pool will be encrypted. On Linux pool, only
                                  "TemporaryDisk" is supported; on Windows pool, "OsDisk" and
                                  "TemporaryDisk" must be specified.
                            ]
                        },
                        "extensions": [
                            {
                                "autoUpgradeMinorVersion": bool,  # Optional.
                                  Indicates whether the extension should use a newer minor version if
                                  one is available at deployment time. Once deployed, however, the
                                  extension will not upgrade minor versions unless redeployed, even
                                  with this property set to true.
                                "name": "str",  # Required. The name of the virtual
                                  machine extension.
                                "protectedSettings": {},  # Optional. The extension
                                  can contain either protectedSettings or protectedSettingsFromKeyVault
                                  or no protected settings at all.
                                "provisionAfterExtensions": [
                                    "str"  # Optional. Collection of extension
                                      names after which this extension needs to be provisioned.
                                ],
                                "publisher": "str",  # Required. The name of the
                                  extension handler publisher.
                                "settings": {},  # Optional. Any object.
                                "type": "str",  # Required. The type of the
                                  extension.
                                "typeHandlerVersion": "str"  # Optional. The version
                                  of script handler.
                            }
                        ],
                        "imageReference": {
                            "exactVersion": "str",  # Optional. The specific version of
                              the platform image or marketplace image used to create the node. This
                              read-only field differs from 'version' only if the value specified for
                              'version' when the pool was created was 'latest'.
                            "offer": "str",  # Optional. For example, UbuntuServer or
                              WindowsServer.
                            "publisher": "str",  # Optional. For example, Canonical or
                              MicrosoftWindowsServer.
                            "sku": "str",  # Optional. For example, 18.04-LTS or
                              2019-Datacenter.
                            "version": "str",  # Optional. A value of 'latest' can be
                              specified to select the latest version of an Image. If omitted, the
                              default is 'latest'.
                            "virtualMachineImageId": "str"  # Optional. This property is
                              mutually exclusive with other ImageReference properties. The Shared Image
                              Gallery Image must have replicas in the same region and must be in the
                              same subscription as the Azure Batch account. If the image version is not
                              specified in the imageId, the latest version will be used. For
                              information about the firewall settings for the Batch Compute Node agent
                              to communicate with the Batch service see
                              https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration.
                        },
                        "licenseType": "str",  # Optional. This only applies to Images that
                          contain the Windows operating system, and should only be used when you hold
                          valid on-premises licenses for the Compute Nodes which will be deployed. If
                          omitted, no on-premises licensing discount is applied. Values are:"n"n
                          Windows_Server - The on-premises license is for Windows Server."n
                          Windows_Client - The on-premises license is for Windows Client.
                        "nodeAgentSKUId": "str",  # Required. The Batch Compute Node agent is
                          a program that runs on each Compute Node in the Pool, and provides the
                          command-and-control interface between the Compute Node and the Batch service.
                          There are different implementations of the Compute Node agent, known as SKUs,
                          for different operating systems. You must specify a Compute Node agent SKU
                          which matches the selected Image reference. To get the list of supported
                          Compute Node agent SKUs along with their list of verified Image references,
                          see the 'List supported Compute Node agent SKUs' operation.
                        "nodePlacementConfiguration": {
                            "policy": "str"  # Optional. Allocation policy used by Batch
                              Service to provision the nodes. If not specified, Batch will use the
                              regional policy. Known values are: "regional", "zonal".
                        },
                        "osDisk": {
                            "ephemeralOSDiskSettings": {
                                "placement": "CacheDisk"  # Optional. Default value
                                  is "CacheDisk". This property can be used by user in the request to
                                  choose the location e.g., cache disk space for Ephemeral OS disk
                                  provisioning. For more information on Ephemeral OS disk size
                                  requirements, please refer to Ephemeral OS disk size requirements for
                                  Windows VMs at
                                  https://docs.microsoft.com/en-us/azure/virtual-machines/windows/ephemeral-os-disks#size-requirements
                                  and Linux VMs at
                                  https://docs.microsoft.com/en-us/azure/virtual-machines/linux/ephemeral-os-disks#size-requirements.
                                  The only acceptable values to pass in are None and "CacheDisk". The
                                  default value is None.
                            }
                        },
                        "windowsConfiguration": {
                            "enableAutomaticUpdates": bool  # Optional. If omitted, the
                              default value is true.
                        }
                    },
                    "vmSize": "str"  # Required. For information about available sizes of virtual
                      machines for Cloud Services Pools (pools created with cloudServiceConfiguration),
                      see Sizes for Cloud Services
                      (https://azure.microsoft.com/documentation/articles/cloud-services-sizes-specs/).
                      Batch supports all Cloud Services VM sizes except ExtraSmall, A1V2 and A2V2. For
                      information about available VM sizes for Pools using Images from the Virtual
                      Machines Marketplace (pools created with virtualMachineConfiguration) see Sizes
                      for Virtual Machines (Linux)
                      (https://azure.microsoft.com/documentation/articles/virtual-machines-linux-sizes/)
                      or Sizes for Virtual Machines (Windows)
                      (https://azure.microsoft.com/documentation/articles/virtual-machines-windows-sizes/).
                      Batch supports all Azure VM sizes except STANDARD_A0 and those with premium
                      storage (STANDARD_GS, STANDARD_DS, and STANDARD_DSV2 series).
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-01-01.15.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json; odata=minimalmetadata"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _content = pool

        request = build_add_request(
            api_version=api_version,
            content_type=content_type,
            content=_content,
            timeout=timeout,
            client_request_id=client_request_id,
            return_client_request_id=return_client_request_id,
            ocp_date=ocp_date,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "batchUrl": self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['client-request-id']=self._deserialize('str', response.headers.get('client-request-id'))
        response_headers['request-id']=self._deserialize('str', response.headers.get('request-id'))
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['DataServiceId']=self._deserialize('str', response.headers.get('DataServiceId'))


        if cls:
            return cls(pipeline_response, None, response_headers)



    @distributed_trace
    def list(
        self,
        *,
        filter: Optional[str] = None,
        select: Optional[str] = None,
        expand: Optional[str] = None,
        max_results: Optional[int] = 1000,
        timeout: Optional[int] = 30,
        client_request_id: Optional[str] = None,
        return_client_request_id: Optional[bool] = False,
        ocp_date: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Lists all of the Pools in the specified Account.

        Lists all of the Pools in the specified Account.

        :keyword filter: An OData $filter clause. For more information on constructing this filter, see
         https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-pools.
         Default value is None.
        :paramtype filter: str
        :keyword select: An OData $select clause. Default value is None.
        :paramtype select: str
        :keyword expand: An OData $expand clause. Default value is None.
        :paramtype expand: str
        :keyword max_results: The maximum number of items to return in the response. A maximum of 1000
         Pools can be returned. Default value is 1000.
        :paramtype max_results: int
        :keyword timeout: The maximum time that the server can spend processing the request, in
         seconds. The default is 30 seconds.
        :paramtype timeout: int
        :keyword client_request_id: The caller-generated request identity, in the form of a GUID with
         no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. Default value is
         None.
        :paramtype client_request_id: str
        :keyword return_client_request_id: Whether the server should return the client-request-id in
         the response. Default value is False.
        :paramtype return_client_request_id: bool
        :keyword ocp_date: The time the request was issued. Client libraries typically set this to the
         current system clock time; set it explicitly if you are calling the REST API directly. Default
         value is None.
        :paramtype ocp_date: ~datetime.datetime
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "odata.nextLink": "str",  # Optional. The URL to get the next set of results.
                    "value": [
                        {
                            "allocationState": "str",  # Optional. Whether the Pool is
                              resizing. Known values are: "steady", "resizing", "stopping".
                            "allocationStateTransitionTime": "2020-02-20 00:00:00",  #
                              Optional. The time at which the Pool entered its current allocation
                              state.
                            "applicationLicenses": [
                                "str"  # Optional. The list of application licenses
                                  must be a subset of available Batch service application licenses. If
                                  a license is requested which is not supported, Pool creation will
                                  fail.
                            ],
                            "applicationPackageReferences": [
                                {
                                    "applicationId": "str",  # Required. The ID
                                      of the application to deploy.
                                    "version": "str"  # Optional. If this is
                                      omitted on a Pool, and no default version is specified for this
                                      application, the request fails with the error code
                                      InvalidApplicationPackageReferences and HTTP status code 409. If
                                      this is omitted on a Task, and no default version is specified
                                      for this application, the Task fails with a pre-processing error.
                                }
                            ],
                            "autoScaleEvaluationInterval": "1 day, 0:00:00",  # Optional.
                              This property is set only if the Pool automatically scales, i.e.
                              enableAutoScale is true.
                            "autoScaleFormula": "str",  # Optional. This property is set
                              only if the Pool automatically scales, i.e. enableAutoScale is true.
                            "autoScaleRun": {
                                "error": {
                                    "code": "str",  # Optional. An identifier for
                                      the autoscale error. Codes are invariant and are intended to be
                                      consumed programmatically.
                                    "message": "str",  # Optional. A message
                                      describing the autoscale error, intended to be suitable for
                                      display in a user interface.
                                    "values": [
                                        {
                                            "name": "str",  # Optional.
                                              The name in the name-value pair.
                                            "value": "str"  # Optional.
                                              The value in the name-value pair.
                                        }
                                    ]
                                },
                                "results": "str",  # Optional. Each variable value is
                                  returned in the form $variable=value, and variables are separated by
                                  semicolons.
                                "timestamp": "2020-02-20 00:00:00"  # Required. The
                                  time at which the autoscale formula was last evaluated.
                            },
                            "certificateReferences": [
                                {
                                    "storeLocation": "str",  # Optional. The
                                      default value is currentuser. This property is applicable only
                                      for Pools configured with Windows Compute Nodes (that is, created
                                      with cloudServiceConfiguration, or with
                                      virtualMachineConfiguration using a Windows Image reference). For
                                      Linux Compute Nodes, the Certificates are stored in a directory
                                      inside the Task working directory and an environment variable
                                      AZ_BATCH_CERTIFICATES_DIR is supplied to the Task to query for
                                      this location. For Certificates with visibility of 'remoteUser',
                                      a 'certs' directory is created in the user's home directory
                                      (e.g., /home/{user-name}/certs) and Certificates are placed in
                                      that directory. Known values are: "currentuser", "localmachine".
                                    "storeName": "str",  # Optional. This
                                      property is applicable only for Pools configured with Windows
                                      Compute Nodes (that is, created with cloudServiceConfiguration,
                                      or with virtualMachineConfiguration using a Windows Image
                                      reference). Common store names include: My, Root, CA, Trust,
                                      Disallowed, TrustedPeople, TrustedPublisher, AuthRoot,
                                      AddressBook, but any custom store name can also be used. The
                                      default value is My.
                                    "thumbprint": "str",  # Required. The
                                      thumbprint of the Certificate.
                                    "thumbprintAlgorithm": "str",  # Required.
                                      The algorithm with which the thumbprint is associated. This must
                                      be sha1.
                                    "visibility": [
                                        "str"  # Optional. You can specify
                                          more than one visibility in this collection. The default is
                                          all Accounts.
                                    ]
                                }
                            ],
                            "cloudServiceConfiguration": {
                                "osFamily": "str",  # Required. Possible values
                                  are:"n2 - OS Family 2, equivalent to Windows Server 2008 R2 SP1."n3 -
                                  OS Family 3, equivalent to Windows Server 2012."n4 - OS Family 4,
                                  equivalent to Windows Server 2012 R2."n5 - OS Family 5, equivalent to
                                  Windows Server 2016."n6 - OS Family 6, equivalent to Windows Server
                                  2019. For more information, see Azure Guest OS Releases
                                  (https://azure.microsoft.com/documentation/articles/cloud-services-guestos-update-matrix/#releases).
                                "osVersion": "str"  # Optional. The default value is
                                  * which specifies the latest operating system version for the
                                  specified OS family.
                            },
                            "creationTime": "2020-02-20 00:00:00",  # Optional. The
                              creation time of the Pool.
                            "currentDedicatedNodes": 0,  # Optional. The number of
                              dedicated Compute Nodes currently in the Pool.
                            "currentLowPriorityNodes": 0,  # Optional. Spot/Low-priority
                              Compute Nodes which have been preempted are included in this count.
                            "displayName": "str",  # Optional. The display name need not
                              be unique and can contain any Unicode characters up to a maximum length
                              of 1024.
                            "eTag": "str",  # Optional. This is an opaque string. You can
                              use it to detect whether the Pool has changed between requests. In
                              particular, you can be pass the ETag when updating a Pool to specify that
                              your changes should take effect only if nobody else has modified the Pool
                              in the meantime.
                            "enableAutoScale": bool,  # Optional. If false, at least one
                              of targetDedicatedNodes and targetLowPriorityNodes must be specified. If
                              true, the autoScaleFormula property is required and the Pool
                              automatically resizes according to the formula. The default value is
                              false.
                            "enableInterNodeCommunication": bool,  # Optional. This
                              imposes restrictions on which Compute Nodes can be assigned to the Pool.
                              Specifying this value can reduce the chance of the requested number of
                              Compute Nodes to be allocated in the Pool.
                            "id": "str",  # Optional. The ID can contain any combination
                              of alphanumeric characters including hyphens and underscores, and cannot
                              contain more than 64 characters. The ID is case-preserving and
                              case-insensitive (that is, you may not have two IDs within an Account
                              that differ only by case).
                            "identity": {
                                "type": "str",  # Required. The list of user
                                  identities associated with the Batch pool. The user identity
                                  dictionary key references will be ARM resource ids in the form:
                                  '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
                                  Known values are: "UserAssigned", "None".
                                "userAssignedIdentities": [
                                    {
                                        "clientId": "str",  # Optional. The
                                          client id of the user assigned identity.
                                        "principalId": "str",  # Optional.
                                          The principal id of the user assigned identity.
                                        "resourceId": "str"  # Required. The
                                          ARM resource id of the user assigned identity.
                                    }
                                ]
                            },
                            "lastModified": "2020-02-20 00:00:00",  # Optional. This is
                              the last time at which the Pool level data, such as the
                              targetDedicatedNodes or enableAutoscale settings, changed. It does not
                              factor in node-level changes such as a Compute Node changing state.
                            "metadata": [
                                {
                                    "name": "str",  # Required. The name of the
                                      metadata item.
                                    "value": "str"  # Required. The value of the
                                      metadata item.
                                }
                            ],
                            "mountConfiguration": [
                                {
                                    "azureBlobFileSystemConfiguration": {
                                        "accountKey": "str",  # Optional.
                                          This property is mutually exclusive with both sasKey and
                                          identity; exactly one must be specified.
                                        "accountName": "str",  # Required.
                                          The Azure Storage Account name.
                                        "blobfuseOptions": "str",  #
                                          Optional. These are 'net use' options in Windows and 'mount'
                                          options in Linux.
                                        "containerName": "str",  # Required.
                                          The Azure Blob Storage Container name.
                                        "identityReference": {
                                            "resourceId": "str"  #
                                              Optional. The ARM resource id of the user assigned
                                              identity.
                                        },
                                        "relativeMountPath": "str",  #
                                          Required. All file systems are mounted relative to the Batch
                                          mounts directory, accessible via the AZ_BATCH_NODE_MOUNTS_DIR
                                          environment variable.
                                        "sasKey": "str"  # Optional. This
                                          property is mutually exclusive with both accountKey and
                                          identity; exactly one must be specified.
                                    },
                                    "azureFileShareConfiguration": {
                                        "accountKey": "str",  # Required. The
                                          Azure Storage account key.
                                        "accountName": "str",  # Required.
                                          The Azure Storage account name.
                                        "azureFileUrl": "str",  # Required.
                                          This is of the form
                                          'https://{account}.file.core.windows.net/'.
                                        "mountOptions": "str",  # Optional.
                                          These are 'net use' options in Windows and 'mount' options in
                                          Linux.
                                        "relativeMountPath": "str"  #
                                          Required. All file systems are mounted relative to the Batch
                                          mounts directory, accessible via the AZ_BATCH_NODE_MOUNTS_DIR
                                          environment variable.
                                    },
                                    "cifsMountConfiguration": {
                                        "mountOptions": "str",  # Optional.
                                          These are 'net use' options in Windows and 'mount' options in
                                          Linux.
                                        "password": "str",  # Required. The
                                          password to use for authentication against the CIFS file
                                          system.
                                        "relativeMountPath": "str",  #
                                          Required. All file systems are mounted relative to the Batch
                                          mounts directory, accessible via the AZ_BATCH_NODE_MOUNTS_DIR
                                          environment variable.
                                        "source": "str",  # Required. The URI
                                          of the file system to mount.
                                        "username": "str"  # Required. The
                                          user to use for authentication against the CIFS file system.
                                    },
                                    "nfsMountConfiguration": {
                                        "mountOptions": "str",  # Optional.
                                          These are 'net use' options in Windows and 'mount' options in
                                          Linux.
                                        "relativeMountPath": "str",  #
                                          Required. All file systems are mounted relative to the Batch
                                          mounts directory, accessible via the AZ_BATCH_NODE_MOUNTS_DIR
                                          environment variable.
                                        "source": "str"  # Required. The URI
                                          of the file system to mount.
                                    }
                                }
                            ],
                            "networkConfiguration": {
                                "dynamicVNetAssignmentScope": "str",  # Optional. The
                                  scope of dynamic vnet assignment. Known values are: "none", "job".
                                "endpointConfiguration": {
                                    "inboundNATPools": [
                                        {
                                            "backendPort": 0,  #
                                              Required. This must be unique within a Batch Pool.
                                              Acceptable values are between 1 and 65535 except for 22,
                                              3389, 29876 and 29877 as these are reserved. If any
                                              reserved values are provided the request fails with HTTP
                                              status code 400.
                                            "frontendPortRangeEnd": 0,  #
                                              Required. Acceptable values range between 1 and 65534
                                              except ports from 50000 to 55000 which are reserved by
                                              the Batch service. All ranges within a Pool must be
                                              distinct and cannot overlap. Each range must contain at
                                              least 40 ports. If any reserved or overlapping values are
                                              provided the request fails with HTTP status code 400.
                                            "frontendPortRangeStart": 0,
                                              # Required. Acceptable values range between 1 and 65534
                                              except ports from 50000 to 55000 which are reserved. All
                                              ranges within a Pool must be distinct and cannot overlap.
                                              Each range must contain at least 40 ports. If any
                                              reserved or overlapping values are provided the request
                                              fails with HTTP status code 400.
                                            "name": "str",  # Required.
                                              The name must be unique within a Batch Pool, can contain
                                              letters, numbers, underscores, periods, and hyphens.
                                              Names must start with a letter or number, must end with a
                                              letter, number, or underscore, and cannot exceed 77
                                              characters.  If any invalid values are provided the
                                              request fails with HTTP status code 400.
                                            "networkSecurityGroupRules":
                                              [
                                                {
                                                    "access":
                                                      "str",  # Required. The action that should be
                                                      taken for a specified IP address, subnet range or
                                                      tag. Known values are: "allow", "deny".
                                                    "priority":
                                                      0,  # Required. Priorities within a Pool must be
                                                      unique and are evaluated in order of priority.
                                                      The lower the number the higher the priority. For
                                                      example, rules could be specified with order
                                                      numbers of 150, 250, and 350. The rule with the
                                                      order number of 150 takes precedence over the
                                                      rule that has an order of 250. Allowed priorities
                                                      are 150 to 4096. If any reserved or duplicate
                                                      values are provided the request fails with HTTP
                                                      status code 400.
                "sourceAddressPrefix": "str",  # Required. Valid
                                                      values are a single IP address (i.e.
                                                      10.10.10.10), IP subnet (i.e. 192.168.1.0/24),
                                                      default tag, or * (for all addresses).  If any
                                                      other values are provided the request fails with
                                                      HTTP status code 400.
                "sourcePortRanges": [
                                                        "str"
                                                          # Optional. Valid values are '"" *' (for all
                                                          ports 0 - 65535), a specific port (i.e. 22),
                                                          or a port range (i.e. 100-200). The ports
                                                          must be in the range of 0 to 65535. Each
                                                          entry in this collection must not overlap any
                                                          other entry (either a range or an individual
                                                          port). If any other values are provided the
                                                          request fails with HTTP status code 400. The
                                                          default value is '*"" '.
                                                    ]
                                                }
                                            ],
                                            "protocol": "str"  #
                                              Required. The protocol of the endpoint. Known values are:
                                              "tcp", "udp".
                                        }
                                    ]
                                },
                                "publicIPAddressConfiguration": {
                                    "ipAddressIds": [
                                        "str"  # Optional. The number of IPs
                                          specified here limits the maximum size of the Pool - 100
                                          dedicated nodes or 100 Spot/Low-priority nodes can be
                                          allocated for each public IP. For example, a pool needing 250
                                          dedicated VMs would need at least 3 public IPs specified.
                                          Each element of this collection is of the form:
                                          /subscriptions/{subscription}/resourceGroups/{group}/providers/Microsoft.Network/publicIPAddresses/{ip}.
                                    ],
                                    "provision": "str"  # Optional. The default
                                      value is BatchManaged. Known values are: "batchmanaged",
                                      "usermanaged", "nopublicipaddresses".
                                },
                                "subnetId": "str"  # Optional. The virtual network
                                  must be in the same region and subscription as the Azure Batch
                                  Account. The specified subnet should have enough free IP addresses to
                                  accommodate the number of Compute Nodes in the Pool. If the subnet
                                  doesn't have enough free IP addresses, the Pool will partially
                                  allocate Nodes and a resize error will occur. The
                                  'MicrosoftAzureBatch' service principal must have the 'Classic
                                  Virtual Machine Contributor' Role-Based Access Control (RBAC) role
                                  for the specified VNet. The specified subnet must allow communication
                                  from the Azure Batch service to be able to schedule Tasks on the
                                  Nodes. This can be verified by checking if the specified VNet has any
                                  associated Network Security Groups (NSG). If communication to the
                                  Nodes in the specified subnet is denied by an NSG, then the Batch
                                  service will set the state of the Compute Nodes to unusable. For
                                  Pools created with virtualMachineConfiguration only ARM virtual
                                  networks ('Microsoft.Network/virtualNetworks') are supported, but for
                                  Pools created with cloudServiceConfiguration both ARM and classic
                                  virtual networks are supported. If the specified VNet has any
                                  associated Network Security Groups (NSG), then a few reserved system
                                  ports must be enabled for inbound communication. For Pools created
                                  with a virtual machine configuration, enable ports 29876 and 29877,
                                  as well as port 22 for Linux and port 3389 for Windows. For Pools
                                  created with a cloud service configuration, enable ports 10100,
                                  20100, and 30100. Also enable outbound connections to Azure Storage
                                  on port 443. For more details see:
                                  https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration.
                            },
                            "resizeErrors": [
                                {
                                    "code": "str",  # Optional. An identifier for
                                      the Pool resize error. Codes are invariant and are intended to be
                                      consumed programmatically.
                                    "message": "str",  # Optional. A message
                                      describing the Pool resize error, intended to be suitable for
                                      display in a user interface.
                                    "values": [
                                        {
                                            "name": "str",  # Optional.
                                              The name in the name-value pair.
                                            "value": "str"  # Optional.
                                              The value in the name-value pair.
                                        }
                                    ]
                                }
                            ],
                            "resizeTimeout": "1 day, 0:00:00",  # Optional. This is the
                              timeout for the most recent resize operation. (The initial sizing when
                              the Pool is created counts as a resize.) The default value is 15 minutes.
                            "startTask": {
                                "commandLine": "str",  # Required. The command line
                                  does not run under a shell, and therefore cannot take advantage of
                                  shell features such as environment variable expansion. If you want to
                                  take advantage of such features, you should invoke the shell in the
                                  command line, for example using "cmd /c MyCommand" in Windows or
                                  "/bin/sh -c MyCommand" in Linux. If the command line refers to file
                                  paths, it should use a relative path (relative to the Task working
                                  directory), or use the Batch provided environment variable
                                  (https://docs.microsoft.com/en-us/azure/batch/batch-compute-node-environment-variables).
                                "containerSettings": {
                                    "containerRunOptions": "str",  # Optional.
                                      These additional options are supplied as arguments to the "docker
                                      create" command, in addition to those controlled by the Batch
                                      Service.
                                    "imageName": "str",  # Required. This is the
                                      full Image reference, as would be specified to "docker pull". If
                                      no tag is provided as part of the Image name, the tag ":latest"
                                      is used as a default.
                                    "registry": {
                                        "identityReference": {
                                            "resourceId": "str"  #
                                              Optional. The ARM resource id of the user assigned
                                              identity.
                                        },
                                        "password": "str",  # Optional. The
                                          password to log into the registry server.
                                        "registryServer": "str",  # Optional.
                                          If omitted, the default is "docker.io".
                                        "username": "str"  # Optional. The
                                          user name to log into the registry server.
                                    },
                                    "workingDirectory": "str"  # Optional. The
                                      default is 'taskWorkingDirectory'. Known values are:
                                      "taskWorkingDirectory", "containerImageDefault".
                                },
                                "environmentSettings": [
                                    {
                                        "name": "str",  # Required. The name
                                          of the environment variable.
                                        "value": "str"  # Optional. The value
                                          of the environment variable.
                                    }
                                ],
                                "maxTaskRetryCount": 0,  # Optional. The Batch
                                  service retries a Task if its exit code is nonzero. Note that this
                                  value specifically controls the number of retries. The Batch service
                                  will try the Task once, and may then retry up to this limit. For
                                  example, if the maximum retry count is 3, Batch tries the Task up to
                                  4 times (one initial try and 3 retries). If the maximum retry count
                                  is 0, the Batch service does not retry the Task. If the maximum retry
                                  count is -1, the Batch service retries the Task without limit,
                                  however this is not recommended for a start task or any task. The
                                  default value is 0 (no retries).
                                "resourceFiles": [
                                    {
                                        "autoStorageContainerName": "str",  #
                                          Optional. The autoStorageContainerName, storageContainerUrl
                                          and httpUrl properties are mutually exclusive and one of them
                                          must be specified.
                                        "blobPrefix": "str",  # Optional. The
                                          property is valid only when autoStorageContainerName or
                                          storageContainerUrl is used. This prefix can be a partial
                                          filename or a subdirectory. If a prefix is not specified, all
                                          the files in the container will be downloaded.
                                        "fileMode": "str",  # Optional. This
                                          property applies only to files being downloaded to Linux
                                          Compute Nodes. It will be ignored if it is specified for a
                                          resourceFile which will be downloaded to a Windows Compute
                                          Node. If this property is not specified for a Linux Compute
                                          Node, then a default value of 0770 is applied to the file.
                                        "filePath": "str",  # Optional. If
                                          the httpUrl property is specified, the filePath is required
                                          and describes the path which the file will be downloaded to,
                                          including the filename. Otherwise, if the
                                          autoStorageContainerName or storageContainerUrl property is
                                          specified, filePath is optional and is the directory to
                                          download the files to. In the case where filePath is used as
                                          a directory, any directory structure already associated with
                                          the input data will be retained in full and appended to the
                                          specified filePath directory. The specified relative path
                                          cannot break out of the Task's working directory (for example
                                          by using '..').
                                        "httpUrl": "str",  # Optional. The
                                          autoStorageContainerName, storageContainerUrl and httpUrl
                                          properties are mutually exclusive and one of them must be
                                          specified. If the URL points to Azure Blob Storage, it must
                                          be readable from compute nodes. There are three ways to get
                                          such a URL for a blob in Azure storage: include a Shared
                                          Access Signature (SAS) granting read permissions on the blob,
                                          use a managed identity with read permission, or set the ACL
                                          for the blob or its container to allow public access.
                                        "identityReference": {
                                            "resourceId": "str"  #
                                              Optional. The ARM resource id of the user assigned
                                              identity.
                                        },
                                        "storageContainerUrl": "str"  #
                                          Optional. The autoStorageContainerName, storageContainerUrl
                                          and httpUrl properties are mutually exclusive and one of them
                                          must be specified. This URL must be readable and listable
                                          from compute nodes. There are three ways to get such a URL
                                          for a container in Azure storage: include a Shared Access
                                          Signature (SAS) granting read and list permissions on the
                                          container, use a managed identity with read and list
                                          permissions, or set the ACL for the container to allow public
                                          access.
                                    }
                                ],
                                "userIdentity": {
                                    "autoUser": {
                                        "elevationLevel": "str",  # Optional.
                                          The default value is nonAdmin. Known values are: "nonadmin",
                                          "admin".
                                        "scope": "str"  # Optional. The
                                          default value is pool. If the pool is running Windows a value
                                          of Task should be specified if stricter isolation between
                                          tasks is required. For example, if the task mutates the
                                          registry in a way which could impact other tasks, or if
                                          certificates have been specified on the pool which should not
                                          be accessible by normal tasks but should be accessible by
                                          StartTasks. Known values are: "task", "pool".
                                    },
                                    "username": "str"  # Optional. The userName
                                      and autoUser properties are mutually exclusive; you must specify
                                      one but not both.
                                },
                                "waitForSuccess": bool  # Optional. If true and the
                                  StartTask fails on a Node, the Batch service retries the StartTask up
                                  to its maximum retry count (maxTaskRetryCount). If the Task has still
                                  not completed successfully after all retries, then the Batch service
                                  marks the Node unusable, and will not schedule Tasks to it. This
                                  condition can be detected via the Compute Node state and failure info
                                  details. If false, the Batch service will not wait for the StartTask
                                  to complete. In this case, other Tasks can start executing on the
                                  Compute Node while the StartTask is still running; and even if the
                                  StartTask fails, new Tasks will continue to be scheduled on the
                                  Compute Node. The default is true.
                            },
                            "state": "str",  # Optional. The current state of the Pool.
                              Known values are: "active", "deleting".
                            "stateTransitionTime": "2020-02-20 00:00:00",  # Optional.
                              The time at which the Pool entered its current state.
                            "stats": {
                                "lastUpdateTime": "2020-02-20 00:00:00",  # Required.
                                  The time at which the statistics were last updated. All statistics
                                  are limited to the range between startTime and lastUpdateTime.
                                "resourceStats": {
                                    "avgCPUPercentage": 0.0,  # Required. The
                                      average CPU usage across all Compute Nodes in the Pool
                                      (percentage per node).
                                    "avgDiskGiB": 0.0,  # Required. The average
                                      used disk space in GiB across all Compute Nodes in the Pool.
                                    "avgMemoryGiB": 0.0,  # Required. The average
                                      memory usage in GiB across all Compute Nodes in the Pool.
                                    "diskReadGiB": 0.0,  # Required. The total
                                      amount of data in GiB of disk reads across all Compute Nodes in
                                      the Pool.
                                    "diskReadIOps": 0.0,  # Required. The total
                                      number of disk read operations across all Compute Nodes in the
                                      Pool.
                                    "diskWriteGiB": 0.0,  # Required. The total
                                      amount of data in GiB of disk writes across all Compute Nodes in
                                      the Pool.
                                    "diskWriteIOps": 0.0,  # Required. The total
                                      number of disk write operations across all Compute Nodes in the
                                      Pool.
                                    "lastUpdateTime": "2020-02-20 00:00:00",  #
                                      Required. The time at which the statistics were last updated. All
                                      statistics are limited to the range between startTime and
                                      lastUpdateTime.
                                    "networkReadGiB": 0.0,  # Required. The total
                                      amount of data in GiB of network reads across all Compute Nodes
                                      in the Pool.
                                    "networkWriteGiB": 0.0,  # Required. The
                                      total amount of data in GiB of network writes across all Compute
                                      Nodes in the Pool.
                                    "peakDiskGiB": 0.0,  # Required. The peak
                                      used disk space in GiB across all Compute Nodes in the Pool.
                                    "peakMemoryGiB": 0.0,  # Required. The peak
                                      memory usage in GiB across all Compute Nodes in the Pool.
                                    "startTime": "2020-02-20 00:00:00"  #
                                      Required. The start time of the time range covered by the
                                      statistics.
                                },
                                "startTime": "2020-02-20 00:00:00",  # Required. The
                                  start time of the time range covered by the statistics.
                                "url": "str",  # Required. The URL for the
                                  statistics.
                                "usageStats": {
                                    "dedicatedCoreTime": "1 day, 0:00:00",  #
                                      Required. The aggregated wall-clock time of the dedicated Compute
                                      Node cores being part of the Pool.
                                    "lastUpdateTime": "2020-02-20 00:00:00",  #
                                      Required. The time at which the statistics were last updated. All
                                      statistics are limited to the range between startTime and
                                      lastUpdateTime.
                                    "startTime": "2020-02-20 00:00:00"  #
                                      Required. The start time of the time range covered by the
                                      statistics.
                                }
                            },
                            "targetDedicatedNodes": 0,  # Optional. The desired number of
                              dedicated Compute Nodes in the Pool.
                            "targetLowPriorityNodes": 0,  # Optional. The desired number
                              of Spot/Low-priority Compute Nodes in the Pool.
                            "taskSchedulingPolicy": {
                                "nodeFillType": "str"  # Required. If not specified,
                                  the default is spread. Known values are: "spread", "pack".
                            },
                            "taskSlotsPerNode": 0,  # Optional. The default value is 1.
                              The maximum value is the smaller of 4 times the number of cores of the
                              vmSize of the pool or 256.
                            "url": "str",  # Optional. The URL of the Pool.
                            "userAccounts": [
                                {
                                    "elevationLevel": "str",  # Optional. The
                                      default value is nonAdmin. Known values are: "nonadmin", "admin".
                                    "linuxUserConfiguration": {
                                        "gid": 0,  # Optional. The uid and
                                          gid properties must be specified together or not at all. If
                                          not specified the underlying operating system picks the gid.
                                        "sshPrivateKey": "str",  # Optional.
                                          The private key must not be password protected. The private
                                          key is used to automatically configure asymmetric-key based
                                          authentication for SSH between Compute Nodes in a Linux Pool
                                          when the Pool's enableInterNodeCommunication property is true
                                          (it is ignored if enableInterNodeCommunication is false). It
                                          does this by placing the key pair into the user's .ssh
                                          directory. If not specified, password-less SSH is not
                                          configured between Compute Nodes (no modification of the
                                          user's .ssh directory is done).
                                        "uid": 0  # Optional. The uid and gid
                                          properties must be specified together or not at all. If not
                                          specified the underlying operating system picks the uid.
                                    },
                                    "name": "str",  # Required. The name of the
                                      user Account.
                                    "password": "str",  # Required. The password
                                      for the user Account.
                                    "windowsUserConfiguration": {
                                        "loginMode": "str"  # Optional. The
                                          default value for VirtualMachineConfiguration Pools is
                                          'batch' and for CloudServiceConfiguration Pools is
                                          'interactive'. Known values are: "batch", "interactive".
                                    }
                                }
                            ],
                            "virtualMachineConfiguration": {
                                "containerConfiguration": {
                                    "containerImageNames": [
                                        "str"  # Optional. This is the full
                                          Image reference, as would be specified to "docker pull". An
                                          Image will be sourced from the default Docker registry unless
                                          the Image is fully qualified with an alternative registry.
                                    ],
                                    "containerRegistries": [
                                        {
                                            "identityReference": {
                                                "resourceId": "str"
                                                  # Optional. The ARM resource id of the user assigned
                                                  identity.
                                            },
                                            "password": "str",  #
                                              Optional. The password to log into the registry server.
                                            "registryServer": "str",  #
                                              Optional. If omitted, the default is "docker.io".
                                            "username": "str"  #
                                              Optional. The user name to log into the registry server.
                                        }
                                    ],
                                    "type": "dockerCompatible"  # Default value
                                      is "dockerCompatible". The container technology to be used. Has
                                      constant value: "dockerCompatible".
                                },
                                "dataDisks": [
                                    {
                                        "caching": "str",  # Optional. The
                                          default value for caching is readwrite. For information about
                                          the caching options see:
                                          https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/27/exploring-windows-azure-drives-disks-and-images/.
                                          Known values are: "none", "readonly", "readwrite".
                                        "diskSizeGB": 0,  # Required. The
                                          initial disk size in gigabytes.
                                        "lun": 0,  # Required. The lun is
                                          used to uniquely identify each data disk. If attaching
                                          multiple disks, each should have a distinct lun. The value
                                          must be between 0 and 63, inclusive.
                                        "storageAccountType": "str"  #
                                          Optional. If omitted, the default is "standard_lrs". Known
                                          values are: "standard_lrs", "premium_lrs".
                                    }
                                ],
                                "diskEncryptionConfiguration": {
                                    "targets": [
                                        "str"  # Optional. If omitted, no
                                          disks on the compute nodes in the pool will be encrypted. On
                                          Linux pool, only "TemporaryDisk" is supported; on Windows
                                          pool, "OsDisk" and "TemporaryDisk" must be specified.
                                    ]
                                },
                                "extensions": [
                                    {
                                        "autoUpgradeMinorVersion": bool,  #
                                          Optional. Indicates whether the extension should use a newer
                                          minor version if one is available at deployment time. Once
                                          deployed, however, the extension will not upgrade minor
                                          versions unless redeployed, even with this property set to
                                          true.
                                        "name": "str",  # Required. The name
                                          of the virtual machine extension.
                                        "protectedSettings": {},  # Optional.
                                          The extension can contain either protectedSettings or
                                          protectedSettingsFromKeyVault or no protected settings at
                                          all.
                                        "provisionAfterExtensions": [
                                            "str"  # Optional. Collection
                                              of extension names after which this extension needs to be
                                              provisioned.
                                        ],
                                        "publisher": "str",  # Required. The
                                          name of the extension handler publisher.
                                        "settings": {},  # Optional. Any
                                          object.
                                        "type": "str",  # Required. The type
                                          of the extension.
                                        "typeHandlerVersion": "str"  #
                                          Optional. The version of script handler.
                                    }
                                ],
                                "imageReference": {
                                    "exactVersion": "str",  # Optional. The
                                      specific version of the platform image or marketplace image used
                                      to create the node. This read-only field differs from 'version'
                                      only if the value specified for 'version' when the pool was
                                      created was 'latest'.
                                    "offer": "str",  # Optional. For example,
                                      UbuntuServer or WindowsServer.
                                    "publisher": "str",  # Optional. For example,
                                      Canonical or MicrosoftWindowsServer.
                                    "sku": "str",  # Optional. For example,
                                      18.04-LTS or 2019-Datacenter.
                                    "version": "str",  # Optional. A value of
                                      'latest' can be specified to select the latest version of an
                                      Image. If omitted, the default is 'latest'.
                                    "virtualMachineImageId": "str"  # Optional.
                                      This property is mutually exclusive with other ImageReference
                                      properties. The Shared Image Gallery Image must have replicas in
                                      the same region and must be in the same subscription as the Azure
                                      Batch account. If the image version is not specified in the
                                      imageId, the latest version will be used. For information about
                                      the firewall settings for the Batch Compute Node agent to
                                      communicate with the Batch service see
                                      https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration.
                                },
                                "licenseType": "str",  # Optional. This only applies
                                  to Images that contain the Windows operating system, and should only
                                  be used when you hold valid on-premises licenses for the Compute
                                  Nodes which will be deployed. If omitted, no on-premises licensing
                                  discount is applied. Values are:"n"n Windows_Server - The on-premises
                                  license is for Windows Server."n Windows_Client - The on-premises
                                  license is for Windows Client.
                                "nodeAgentSKUId": "str",  # Required. The Batch
                                  Compute Node agent is a program that runs on each Compute Node in the
                                  Pool, and provides the command-and-control interface between the
                                  Compute Node and the Batch service. There are different
                                  implementations of the Compute Node agent, known as SKUs, for
                                  different operating systems. You must specify a Compute Node agent
                                  SKU which matches the selected Image reference. To get the list of
                                  supported Compute Node agent SKUs along with their list of verified
                                  Image references, see the 'List supported Compute Node agent SKUs'
                                  operation.
                                "nodePlacementConfiguration": {
                                    "policy": "str"  # Optional. Allocation
                                      policy used by Batch Service to provision the nodes. If not
                                      specified, Batch will use the regional policy. Known values are:
                                      "regional", "zonal".
                                },
                                "osDisk": {
                                    "ephemeralOSDiskSettings": {
                                        "placement": "CacheDisk"  # Optional.
                                          Default value is "CacheDisk". This property can be used by
                                          user in the request to choose the location e.g., cache disk
                                          space for Ephemeral OS disk provisioning. For more
                                          information on Ephemeral OS disk size requirements, please
                                          refer to Ephemeral OS disk size requirements for Windows VMs
                                          at
                                          https://docs.microsoft.com/en-us/azure/virtual-machines/windows/ephemeral-os-disks#size-requirements
                                          and Linux VMs at
                                          https://docs.microsoft.com/en-us/azure/virtual-machines/linux/ephemeral-os-disks#size-requirements.
                                          The only acceptable values to pass in are None and
                                          "CacheDisk". The default value is None.
                                    }
                                },
                                "windowsConfiguration": {
                                    "enableAutomaticUpdates": bool  # Optional.
                                      If omitted, the default value is true.
                                }
                            },
                            "vmSize": "str"  # Optional. For information about available
                              sizes of virtual machines in Pools, see Choose a VM size for Compute
                              Nodes in an Azure Batch Pool
                              (https://docs.microsoft.com/azure/batch/batch-pool-vm-sizes).
                        }
                    ]
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-01-01.15.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_list_request(
                    api_version=api_version,
                    filter=filter,
                    select=select,
                    expand=expand,
                    max_results=max_results,
                    timeout=timeout,
                    client_request_id=client_request_id,
                    return_client_request_id=return_client_request_id,
                    ocp_date=ocp_date,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "batchUrl": self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                
                request = build_list_request(
                    client_request_id=client_request_id,
                    return_client_request_id=return_client_request_id,
                    ocp_date=ocp_date,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "batchUrl": self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(next_link, **path_format_arguments)  # type: ignore

                path_format_arguments = {
                    "batchUrl": self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("odata.nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
                request,
                stream=False,
                **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )


    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self,
        pool_id: str,
        *,
        timeout: Optional[int] = 30,
        client_request_id: Optional[str] = None,
        return_client_request_id: Optional[bool] = False,
        ocp_date: Optional[datetime.datetime] = None,
        if_match: Optional[str] = None,
        if_none_match: Optional[str] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> None:
        """Deletes a Pool from the specified Account.

        When you request that a Pool be deleted, the following actions occur: the Pool state is set to
        deleting; any ongoing resize operation on the Pool are stopped; the Batch service starts
        resizing the Pool to zero Compute Nodes; any Tasks running on existing Compute Nodes are
        terminated and requeued (as if a resize Pool operation had been requested with the default
        requeue option); finally, the Pool is removed from the system. Because running Tasks are
        requeued, the user can rerun these Tasks by updating their Job to target a different Pool. The
        Tasks can then run on the new Pool. If you want to override the requeue behavior, then you
        should call resize Pool explicitly to shrink the Pool to zero size before deleting the Pool. If
        you call an Update, Patch or Delete API on a Pool in the deleting state, it will fail with HTTP
        status code 409 with error code PoolBeingDeleted.

        :param pool_id: The ID of the Pool to delete.
        :type pool_id: str
        :keyword timeout: The maximum time that the server can spend processing the request, in
         seconds. The default is 30 seconds.
        :paramtype timeout: int
        :keyword client_request_id: The caller-generated request identity, in the form of a GUID with
         no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. Default value is
         None.
        :paramtype client_request_id: str
        :keyword return_client_request_id: Whether the server should return the client-request-id in
         the response. Default value is False.
        :paramtype return_client_request_id: bool
        :keyword ocp_date: The time the request was issued. Client libraries typically set this to the
         current system clock time; set it explicitly if you are calling the REST API directly. Default
         value is None.
        :paramtype ocp_date: ~datetime.datetime
        :keyword if_match: An ETag value associated with the version of the resource known to the
         client. The operation will be performed only if the resource's current ETag on the service
         exactly matches the value specified by the client. Default value is None.
        :paramtype if_match: str
        :keyword if_none_match: An ETag value associated with the version of the resource known to the
         client. The operation will be performed only if the resource's current ETag on the service does
         not match the value specified by the client. Default value is None.
        :paramtype if_none_match: str
        :keyword if_modified_since: A timestamp indicating the last modified time of the resource known
         to the client. The operation will be performed only if the resource on the service has been
         modified since the specified time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A timestamp indicating the last modified time of the resource
         known to the client. The operation will be performed only if the resource on the service has
         not been modified since the specified time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-01-01.15.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_delete_request(
            pool_id=pool_id,
            api_version=api_version,
            timeout=timeout,
            client_request_id=client_request_id,
            return_client_request_id=return_client_request_id,
            ocp_date=ocp_date,
            if_match=if_match,
            if_none_match=if_none_match,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "batchUrl": self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['client-request-id']=self._deserialize('str', response.headers.get('client-request-id'))
        response_headers['request-id']=self._deserialize('str', response.headers.get('request-id'))


        if cls:
            return cls(pipeline_response, None, response_headers)



    @distributed_trace
    def exists(  # pylint: disable=inconsistent-return-statements
        self,
        pool_id: str,
        *,
        timeout: Optional[int] = 30,
        client_request_id: Optional[str] = None,
        return_client_request_id: Optional[bool] = False,
        ocp_date: Optional[datetime.datetime] = None,
        if_match: Optional[str] = None,
        if_none_match: Optional[str] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> None:
        """Gets basic properties of a Pool.

        :param pool_id: The ID of the Pool to get.
        :type pool_id: str
        :keyword timeout: The maximum time that the server can spend processing the request, in
         seconds. The default is 30 seconds.
        :paramtype timeout: int
        :keyword client_request_id: The caller-generated request identity, in the form of a GUID with
         no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. Default value is
         None.
        :paramtype client_request_id: str
        :keyword return_client_request_id: Whether the server should return the client-request-id in
         the response. Default value is False.
        :paramtype return_client_request_id: bool
        :keyword ocp_date: The time the request was issued. Client libraries typically set this to the
         current system clock time; set it explicitly if you are calling the REST API directly. Default
         value is None.
        :paramtype ocp_date: ~datetime.datetime
        :keyword if_match: An ETag value associated with the version of the resource known to the
         client. The operation will be performed only if the resource's current ETag on the service
         exactly matches the value specified by the client. Default value is None.
        :paramtype if_match: str
        :keyword if_none_match: An ETag value associated with the version of the resource known to the
         client. The operation will be performed only if the resource's current ETag on the service does
         not match the value specified by the client. Default value is None.
        :paramtype if_none_match: str
        :keyword if_modified_since: A timestamp indicating the last modified time of the resource known
         to the client. The operation will be performed only if the resource on the service has been
         modified since the specified time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A timestamp indicating the last modified time of the resource
         known to the client. The operation will be performed only if the resource on the service has
         not been modified since the specified time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-01-01.15.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_exists_request(
            pool_id=pool_id,
            api_version=api_version,
            timeout=timeout,
            client_request_id=client_request_id,
            return_client_request_id=return_client_request_id,
            ocp_date=ocp_date,
            if_match=if_match,
            if_none_match=if_none_match,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "batchUrl": self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 200:
            response_headers['client-request-id']=self._deserialize('str', response.headers.get('client-request-id'))
            response_headers['request-id']=self._deserialize('str', response.headers.get('request-id'))
            response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
            response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
            

        if cls:
            return cls(pipeline_response, None, response_headers)



    @distributed_trace
    def get(
        self,
        pool_id: str,
        *,
        select: Optional[str] = None,
        expand: Optional[str] = None,
        timeout: Optional[int] = 30,
        client_request_id: Optional[str] = None,
        return_client_request_id: Optional[bool] = False,
        ocp_date: Optional[datetime.datetime] = None,
        if_match: Optional[str] = None,
        if_none_match: Optional[str] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> JSON:
        """Gets information about the specified Pool.

        :param pool_id: The ID of the Pool to get.
        :type pool_id: str
        :keyword select: An OData $select clause. Default value is None.
        :paramtype select: str
        :keyword expand: An OData $expand clause. Default value is None.
        :paramtype expand: str
        :keyword timeout: The maximum time that the server can spend processing the request, in
         seconds. The default is 30 seconds.
        :paramtype timeout: int
        :keyword client_request_id: The caller-generated request identity, in the form of a GUID with
         no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. Default value is
         None.
        :paramtype client_request_id: str
        :keyword return_client_request_id: Whether the server should return the client-request-id in
         the response. Default value is False.
        :paramtype return_client_request_id: bool
        :keyword ocp_date: The time the request was issued. Client libraries typically set this to the
         current system clock time; set it explicitly if you are calling the REST API directly. Default
         value is None.
        :paramtype ocp_date: ~datetime.datetime
        :keyword if_match: An ETag value associated with the version of the resource known to the
         client. The operation will be performed only if the resource's current ETag on the service
         exactly matches the value specified by the client. Default value is None.
        :paramtype if_match: str
        :keyword if_none_match: An ETag value associated with the version of the resource known to the
         client. The operation will be performed only if the resource's current ETag on the service does
         not match the value specified by the client. Default value is None.
        :paramtype if_none_match: str
        :keyword if_modified_since: A timestamp indicating the last modified time of the resource known
         to the client. The operation will be performed only if the resource on the service has been
         modified since the specified time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A timestamp indicating the last modified time of the resource
         known to the client. The operation will be performed only if the resource on the service has
         not been modified since the specified time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "allocationState": "str",  # Optional. Whether the Pool is resizing. Known
                      values are: "steady", "resizing", "stopping".
                    "allocationStateTransitionTime": "2020-02-20 00:00:00",  # Optional. The time
                      at which the Pool entered its current allocation state.
                    "applicationLicenses": [
                        "str"  # Optional. The list of application licenses must be a subset
                          of available Batch service application licenses. If a license is requested
                          which is not supported, Pool creation will fail.
                    ],
                    "applicationPackageReferences": [
                        {
                            "applicationId": "str",  # Required. The ID of the
                              application to deploy.
                            "version": "str"  # Optional. If this is omitted on a Pool,
                              and no default version is specified for this application, the request
                              fails with the error code InvalidApplicationPackageReferences and HTTP
                              status code 409. If this is omitted on a Task, and no default version is
                              specified for this application, the Task fails with a pre-processing
                              error.
                        }
                    ],
                    "autoScaleEvaluationInterval": "1 day, 0:00:00",  # Optional. This property
                      is set only if the Pool automatically scales, i.e. enableAutoScale is true.
                    "autoScaleFormula": "str",  # Optional. This property is set only if the Pool
                      automatically scales, i.e. enableAutoScale is true.
                    "autoScaleRun": {
                        "error": {
                            "code": "str",  # Optional. An identifier for the autoscale
                              error. Codes are invariant and are intended to be consumed
                              programmatically.
                            "message": "str",  # Optional. A message describing the
                              autoscale error, intended to be suitable for display in a user interface.
                            "values": [
                                {
                                    "name": "str",  # Optional. The name in the
                                      name-value pair.
                                    "value": "str"  # Optional. The value in the
                                      name-value pair.
                                }
                            ]
                        },
                        "results": "str",  # Optional. Each variable value is returned in the
                          form $variable=value, and variables are separated by semicolons.
                        "timestamp": "2020-02-20 00:00:00"  # Required. The time at which the
                          autoscale formula was last evaluated.
                    },
                    "certificateReferences": [
                        {
                            "storeLocation": "str",  # Optional. The default value is
                              currentuser. This property is applicable only for Pools configured with
                              Windows Compute Nodes (that is, created with cloudServiceConfiguration,
                              or with virtualMachineConfiguration using a Windows Image reference). For
                              Linux Compute Nodes, the Certificates are stored in a directory inside
                              the Task working directory and an environment variable
                              AZ_BATCH_CERTIFICATES_DIR is supplied to the Task to query for this
                              location. For Certificates with visibility of 'remoteUser', a 'certs'
                              directory is created in the user's home directory (e.g.,
                              /home/{user-name}/certs) and Certificates are placed in that directory.
                              Known values are: "currentuser", "localmachine".
                            "storeName": "str",  # Optional. This property is applicable
                              only for Pools configured with Windows Compute Nodes (that is, created
                              with cloudServiceConfiguration, or with virtualMachineConfiguration using
                              a Windows Image reference). Common store names include: My, Root, CA,
                              Trust, Disallowed, TrustedPeople, TrustedPublisher, AuthRoot,
                              AddressBook, but any custom store name can also be used. The default
                              value is My.
                            "thumbprint": "str",  # Required. The thumbprint of the
                              Certificate.
                            "thumbprintAlgorithm": "str",  # Required. The algorithm with
                              which the thumbprint is associated. This must be sha1.
                            "visibility": [
                                "str"  # Optional. You can specify more than one
                                  visibility in this collection. The default is all Accounts.
                            ]
                        }
                    ],
                    "cloudServiceConfiguration": {
                        "osFamily": "str",  # Required. Possible values are:"n2 - OS Family
                          2, equivalent to Windows Server 2008 R2 SP1."n3 - OS Family 3, equivalent to
                          Windows Server 2012."n4 - OS Family 4, equivalent to Windows Server 2012
                          R2."n5 - OS Family 5, equivalent to Windows Server 2016."n6 - OS Family 6,
                          equivalent to Windows Server 2019. For more information, see Azure Guest OS
                          Releases
                          (https://azure.microsoft.com/documentation/articles/cloud-services-guestos-update-matrix/#releases).
                        "osVersion": "str"  # Optional. The default value is * which
                          specifies the latest operating system version for the specified OS family.
                    },
                    "creationTime": "2020-02-20 00:00:00",  # Optional. The creation time of the
                      Pool.
                    "currentDedicatedNodes": 0,  # Optional. The number of dedicated Compute
                      Nodes currently in the Pool.
                    "currentLowPriorityNodes": 0,  # Optional. Spot/Low-priority Compute Nodes
                      which have been preempted are included in this count.
                    "displayName": "str",  # Optional. The display name need not be unique and
                      can contain any Unicode characters up to a maximum length of 1024.
                    "eTag": "str",  # Optional. This is an opaque string. You can use it to
                      detect whether the Pool has changed between requests. In particular, you can be
                      pass the ETag when updating a Pool to specify that your changes should take
                      effect only if nobody else has modified the Pool in the meantime.
                    "enableAutoScale": bool,  # Optional. If false, at least one of
                      targetDedicatedNodes and targetLowPriorityNodes must be specified. If true, the
                      autoScaleFormula property is required and the Pool automatically resizes
                      according to the formula. The default value is false.
                    "enableInterNodeCommunication": bool,  # Optional. This imposes restrictions
                      on which Compute Nodes can be assigned to the Pool. Specifying this value can
                      reduce the chance of the requested number of Compute Nodes to be allocated in the
                      Pool.
                    "id": "str",  # Optional. The ID can contain any combination of alphanumeric
                      characters including hyphens and underscores, and cannot contain more than 64
                      characters. The ID is case-preserving and case-insensitive (that is, you may not
                      have two IDs within an Account that differ only by case).
                    "identity": {
                        "type": "str",  # Required. The list of user identities associated
                          with the Batch pool. The user identity dictionary key references will be ARM
                          resource ids in the form:
                          '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
                          Known values are: "UserAssigned", "None".
                        "userAssignedIdentities": [
                            {
                                "clientId": "str",  # Optional. The client id of the
                                  user assigned identity.
                                "principalId": "str",  # Optional. The principal id
                                  of the user assigned identity.
                                "resourceId": "str"  # Required. The ARM resource id
                                  of the user assigned identity.
                            }
                        ]
                    },
                    "lastModified": "2020-02-20 00:00:00",  # Optional. This is the last time at
                      which the Pool level data, such as the targetDedicatedNodes or enableAutoscale
                      settings, changed. It does not factor in node-level changes such as a Compute
                      Node changing state.
                    "metadata": [
                        {
                            "name": "str",  # Required. The name of the metadata item.
                            "value": "str"  # Required. The value of the metadata item.
                        }
                    ],
                    "mountConfiguration": [
                        {
                            "azureBlobFileSystemConfiguration": {
                                "accountKey": "str",  # Optional. This property is
                                  mutually exclusive with both sasKey and identity; exactly one must be
                                  specified.
                                "accountName": "str",  # Required. The Azure Storage
                                  Account name.
                                "blobfuseOptions": "str",  # Optional. These are 'net
                                  use' options in Windows and 'mount' options in Linux.
                                "containerName": "str",  # Required. The Azure Blob
                                  Storage Container name.
                                "identityReference": {
                                    "resourceId": "str"  # Optional. The ARM
                                      resource id of the user assigned identity.
                                },
                                "relativeMountPath": "str",  # Required. All file
                                  systems are mounted relative to the Batch mounts directory,
                                  accessible via the AZ_BATCH_NODE_MOUNTS_DIR environment variable.
                                "sasKey": "str"  # Optional. This property is
                                  mutually exclusive with both accountKey and identity; exactly one
                                  must be specified.
                            },
                            "azureFileShareConfiguration": {
                                "accountKey": "str",  # Required. The Azure Storage
                                  account key.
                                "accountName": "str",  # Required. The Azure Storage
                                  account name.
                                "azureFileUrl": "str",  # Required. This is of the
                                  form 'https://{account}.file.core.windows.net/'.
                                "mountOptions": "str",  # Optional. These are 'net
                                  use' options in Windows and 'mount' options in Linux.
                                "relativeMountPath": "str"  # Required. All file
                                  systems are mounted relative to the Batch mounts directory,
                                  accessible via the AZ_BATCH_NODE_MOUNTS_DIR environment variable.
                            },
                            "cifsMountConfiguration": {
                                "mountOptions": "str",  # Optional. These are 'net
                                  use' options in Windows and 'mount' options in Linux.
                                "password": "str",  # Required. The password to use
                                  for authentication against the CIFS file system.
                                "relativeMountPath": "str",  # Required. All file
                                  systems are mounted relative to the Batch mounts directory,
                                  accessible via the AZ_BATCH_NODE_MOUNTS_DIR environment variable.
                                "source": "str",  # Required. The URI of the file
                                  system to mount.
                                "username": "str"  # Required. The user to use for
                                  authentication against the CIFS file system.
                            },
                            "nfsMountConfiguration": {
                                "mountOptions": "str",  # Optional. These are 'net
                                  use' options in Windows and 'mount' options in Linux.
                                "relativeMountPath": "str",  # Required. All file
                                  systems are mounted relative to the Batch mounts directory,
                                  accessible via the AZ_BATCH_NODE_MOUNTS_DIR environment variable.
                                "source": "str"  # Required. The URI of the file
                                  system to mount.
                            }
                        }
                    ],
                    "networkConfiguration": {
                        "dynamicVNetAssignmentScope": "str",  # Optional. The scope of
                          dynamic vnet assignment. Known values are: "none", "job".
                        "endpointConfiguration": {
                            "inboundNATPools": [
                                {
                                    "backendPort": 0,  # Required. This must be
                                      unique within a Batch Pool. Acceptable values are between 1 and
                                      65535 except for 22, 3389, 29876 and 29877 as these are reserved.
                                      If any reserved values are provided the request fails with HTTP
                                      status code 400.
                                    "frontendPortRangeEnd": 0,  # Required.
                                      Acceptable values range between 1 and 65534 except ports from
                                      50000 to 55000 which are reserved by the Batch service. All
                                      ranges within a Pool must be distinct and cannot overlap. Each
                                      range must contain at least 40 ports. If any reserved or
                                      overlapping values are provided the request fails with HTTP
                                      status code 400.
                                    "frontendPortRangeStart": 0,  # Required.
                                      Acceptable values range between 1 and 65534 except ports from
                                      50000 to 55000 which are reserved. All ranges within a Pool must
                                      be distinct and cannot overlap. Each range must contain at least
                                      40 ports. If any reserved or overlapping values are provided the
                                      request fails with HTTP status code 400.
                                    "name": "str",  # Required. The name must be
                                      unique within a Batch Pool, can contain letters, numbers,
                                      underscores, periods, and hyphens. Names must start with a letter
                                      or number, must end with a letter, number, or underscore, and
                                      cannot exceed 77 characters.  If any invalid values are provided
                                      the request fails with HTTP status code 400.
                                    "networkSecurityGroupRules": [
                                        {
                                            "access": "str",  # Required.
                                              The action that should be taken for a specified IP
                                              address, subnet range or tag. Known values are: "allow",
                                              "deny".
                                            "priority": 0,  # Required.
                                              Priorities within a Pool must be unique and are evaluated
                                              in order of priority. The lower the number the higher the
                                              priority. For example, rules could be specified with
                                              order numbers of 150, 250, and 350. The rule with the
                                              order number of 150 takes precedence over the rule that
                                              has an order of 250. Allowed priorities are 150 to 4096.
                                              If any reserved or duplicate values are provided the
                                              request fails with HTTP status code 400.
                                            "sourceAddressPrefix": "str",
                                              # Required. Valid values are a single IP address (i.e.
                                              10.10.10.10), IP subnet (i.e. 192.168.1.0/24), default
                                              tag, or * (for all addresses).  If any other values are
                                              provided the request fails with HTTP status code 400.
                                            "sourcePortRanges": [
                                                "str"  # Optional.
                                                  Valid values are '"" *' (for all ports 0 - 65535), a
                                                  specific port (i.e. 22), or a port range (i.e.
                                                  100-200). The ports must be in the range of 0 to
                                                  65535. Each entry in this collection must not overlap
                                                  any other entry (either a range or an individual
                                                  port). If any other values are provided the request
                                                  fails with HTTP status code 400. The default value is
                                                  '*"" '.
                                            ]
                                        }
                                    ],
                                    "protocol": "str"  # Required. The protocol
                                      of the endpoint. Known values are: "tcp", "udp".
                                }
                            ]
                        },
                        "publicIPAddressConfiguration": {
                            "ipAddressIds": [
                                "str"  # Optional. The number of IPs specified here
                                  limits the maximum size of the Pool - 100 dedicated nodes or 100
                                  Spot/Low-priority nodes can be allocated for each public IP. For
                                  example, a pool needing 250 dedicated VMs would need at least 3
                                  public IPs specified. Each element of this collection is of the form:
                                  /subscriptions/{subscription}/resourceGroups/{group}/providers/Microsoft.Network/publicIPAddresses/{ip}.
                            ],
                            "provision": "str"  # Optional. The default value is
                              BatchManaged. Known values are: "batchmanaged", "usermanaged",
                              "nopublicipaddresses".
                        },
                        "subnetId": "str"  # Optional. The virtual network must be in the
                          same region and subscription as the Azure Batch Account. The specified subnet
                          should have enough free IP addresses to accommodate the number of Compute
                          Nodes in the Pool. If the subnet doesn't have enough free IP addresses, the
                          Pool will partially allocate Nodes and a resize error will occur. The
                          'MicrosoftAzureBatch' service principal must have the 'Classic Virtual
                          Machine Contributor' Role-Based Access Control (RBAC) role for the specified
                          VNet. The specified subnet must allow communication from the Azure Batch
                          service to be able to schedule Tasks on the Nodes. This can be verified by
                          checking if the specified VNet has any associated Network Security Groups
                          (NSG). If communication to the Nodes in the specified subnet is denied by an
                          NSG, then the Batch service will set the state of the Compute Nodes to
                          unusable. For Pools created with virtualMachineConfiguration only ARM virtual
                          networks ('Microsoft.Network/virtualNetworks') are supported, but for Pools
                          created with cloudServiceConfiguration both ARM and classic virtual networks
                          are supported. If the specified VNet has any associated Network Security
                          Groups (NSG), then a few reserved system ports must be enabled for inbound
                          communication. For Pools created with a virtual machine configuration, enable
                          ports 29876 and 29877, as well as port 22 for Linux and port 3389 for
                          Windows. For Pools created with a cloud service configuration, enable ports
                          10100, 20100, and 30100. Also enable outbound connections to Azure Storage on
                          port 443. For more details see:
                          https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration.
                    },
                    "resizeErrors": [
                        {
                            "code": "str",  # Optional. An identifier for the Pool resize
                              error. Codes are invariant and are intended to be consumed
                              programmatically.
                            "message": "str",  # Optional. A message describing the Pool
                              resize error, intended to be suitable for display in a user interface.
                            "values": [
                                {
                                    "name": "str",  # Optional. The name in the
                                      name-value pair.
                                    "value": "str"  # Optional. The value in the
                                      name-value pair.
                                }
                            ]
                        }
                    ],
                    "resizeTimeout": "1 day, 0:00:00",  # Optional. This is the timeout for the
                      most recent resize operation. (The initial sizing when the Pool is created counts
                      as a resize.) The default value is 15 minutes.
                    "startTask": {
                        "commandLine": "str",  # Required. The command line does not run
                          under a shell, and therefore cannot take advantage of shell features such as
                          environment variable expansion. If you want to take advantage of such
                          features, you should invoke the shell in the command line, for example using
                          "cmd /c MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux. If the
                          command line refers to file paths, it should use a relative path (relative to
                          the Task working directory), or use the Batch provided environment variable
                          (https://docs.microsoft.com/en-us/azure/batch/batch-compute-node-environment-variables).
                        "containerSettings": {
                            "containerRunOptions": "str",  # Optional. These additional
                              options are supplied as arguments to the "docker create" command, in
                              addition to those controlled by the Batch Service.
                            "imageName": "str",  # Required. This is the full Image
                              reference, as would be specified to "docker pull". If no tag is provided
                              as part of the Image name, the tag ":latest" is used as a default.
                            "registry": {
                                "identityReference": {
                                    "resourceId": "str"  # Optional. The ARM
                                      resource id of the user assigned identity.
                                },
                                "password": "str",  # Optional. The password to log
                                  into the registry server.
                                "registryServer": "str",  # Optional. If omitted, the
                                  default is "docker.io".
                                "username": "str"  # Optional. The user name to log
                                  into the registry server.
                            },
                            "workingDirectory": "str"  # Optional. The default is
                              'taskWorkingDirectory'. Known values are: "taskWorkingDirectory",
                              "containerImageDefault".
                        },
                        "environmentSettings": [
                            {
                                "name": "str",  # Required. The name of the
                                  environment variable.
                                "value": "str"  # Optional. The value of the
                                  environment variable.
                            }
                        ],
                        "maxTaskRetryCount": 0,  # Optional. The Batch service retries a Task
                          if its exit code is nonzero. Note that this value specifically controls the
                          number of retries. The Batch service will try the Task once, and may then
                          retry up to this limit. For example, if the maximum retry count is 3, Batch
                          tries the Task up to 4 times (one initial try and 3 retries). If the maximum
                          retry count is 0, the Batch service does not retry the Task. If the maximum
                          retry count is -1, the Batch service retries the Task without limit, however
                          this is not recommended for a start task or any task. The default value is 0
                          (no retries).
                        "resourceFiles": [
                            {
                                "autoStorageContainerName": "str",  # Optional. The
                                  autoStorageContainerName, storageContainerUrl and httpUrl properties
                                  are mutually exclusive and one of them must be specified.
                                "blobPrefix": "str",  # Optional. The property is
                                  valid only when autoStorageContainerName or storageContainerUrl is
                                  used. This prefix can be a partial filename or a subdirectory. If a
                                  prefix is not specified, all the files in the container will be
                                  downloaded.
                                "fileMode": "str",  # Optional. This property applies
                                  only to files being downloaded to Linux Compute Nodes. It will be
                                  ignored if it is specified for a resourceFile which will be
                                  downloaded to a Windows Compute Node. If this property is not
                                  specified for a Linux Compute Node, then a default value of 0770 is
                                  applied to the file.
                                "filePath": "str",  # Optional. If the httpUrl
                                  property is specified, the filePath is required and describes the
                                  path which the file will be downloaded to, including the filename.
                                  Otherwise, if the autoStorageContainerName or storageContainerUrl
                                  property is specified, filePath is optional and is the directory to
                                  download the files to. In the case where filePath is used as a
                                  directory, any directory structure already associated with the input
                                  data will be retained in full and appended to the specified filePath
                                  directory. The specified relative path cannot break out of the Task's
                                  working directory (for example by using '..').
                                "httpUrl": "str",  # Optional. The
                                  autoStorageContainerName, storageContainerUrl and httpUrl properties
                                  are mutually exclusive and one of them must be specified. If the URL
                                  points to Azure Blob Storage, it must be readable from compute nodes.
                                  There are three ways to get such a URL for a blob in Azure storage:
                                  include a Shared Access Signature (SAS) granting read permissions on
                                  the blob, use a managed identity with read permission, or set the ACL
                                  for the blob or its container to allow public access.
                                "identityReference": {
                                    "resourceId": "str"  # Optional. The ARM
                                      resource id of the user assigned identity.
                                },
                                "storageContainerUrl": "str"  # Optional. The
                                  autoStorageContainerName, storageContainerUrl and httpUrl properties
                                  are mutually exclusive and one of them must be specified. This URL
                                  must be readable and listable from compute nodes. There are three
                                  ways to get such a URL for a container in Azure storage: include a
                                  Shared Access Signature (SAS) granting read and list permissions on
                                  the container, use a managed identity with read and list permissions,
                                  or set the ACL for the container to allow public access.
                            }
                        ],
                        "userIdentity": {
                            "autoUser": {
                                "elevationLevel": "str",  # Optional. The default
                                  value is nonAdmin. Known values are: "nonadmin", "admin".
                                "scope": "str"  # Optional. The default value is
                                  pool. If the pool is running Windows a value of Task should be
                                  specified if stricter isolation between tasks is required. For
                                  example, if the task mutates the registry in a way which could impact
                                  other tasks, or if certificates have been specified on the pool which
                                  should not be accessible by normal tasks but should be accessible by
                                  StartTasks. Known values are: "task", "pool".
                            },
                            "username": "str"  # Optional. The userName and autoUser
                              properties are mutually exclusive; you must specify one but not both.
                        },
                        "waitForSuccess": bool  # Optional. If true and the StartTask fails
                          on a Node, the Batch service retries the StartTask up to its maximum retry
                          count (maxTaskRetryCount). If the Task has still not completed successfully
                          after all retries, then the Batch service marks the Node unusable, and will
                          not schedule Tasks to it. This condition can be detected via the Compute Node
                          state and failure info details. If false, the Batch service will not wait for
                          the StartTask to complete. In this case, other Tasks can start executing on
                          the Compute Node while the StartTask is still running; and even if the
                          StartTask fails, new Tasks will continue to be scheduled on the Compute Node.
                          The default is true.
                    },
                    "state": "str",  # Optional. The current state of the Pool. Known values are:
                      "active", "deleting".
                    "stateTransitionTime": "2020-02-20 00:00:00",  # Optional. The time at which
                      the Pool entered its current state.
                    "stats": {
                        "lastUpdateTime": "2020-02-20 00:00:00",  # Required. The time at
                          which the statistics were last updated. All statistics are limited to the
                          range between startTime and lastUpdateTime.
                        "resourceStats": {
                            "avgCPUPercentage": 0.0,  # Required. The average CPU usage
                              across all Compute Nodes in the Pool (percentage per node).
                            "avgDiskGiB": 0.0,  # Required. The average used disk space
                              in GiB across all Compute Nodes in the Pool.
                            "avgMemoryGiB": 0.0,  # Required. The average memory usage in
                              GiB across all Compute Nodes in the Pool.
                            "diskReadGiB": 0.0,  # Required. The total amount of data in
                              GiB of disk reads across all Compute Nodes in the Pool.
                            "diskReadIOps": 0.0,  # Required. The total number of disk
                              read operations across all Compute Nodes in the Pool.
                            "diskWriteGiB": 0.0,  # Required. The total amount of data in
                              GiB of disk writes across all Compute Nodes in the Pool.
                            "diskWriteIOps": 0.0,  # Required. The total number of disk
                              write operations across all Compute Nodes in the Pool.
                            "lastUpdateTime": "2020-02-20 00:00:00",  # Required. The
                              time at which the statistics were last updated. All statistics are
                              limited to the range between startTime and lastUpdateTime.
                            "networkReadGiB": 0.0,  # Required. The total amount of data
                              in GiB of network reads across all Compute Nodes in the Pool.
                            "networkWriteGiB": 0.0,  # Required. The total amount of data
                              in GiB of network writes across all Compute Nodes in the Pool.
                            "peakDiskGiB": 0.0,  # Required. The peak used disk space in
                              GiB across all Compute Nodes in the Pool.
                            "peakMemoryGiB": 0.0,  # Required. The peak memory usage in
                              GiB across all Compute Nodes in the Pool.
                            "startTime": "2020-02-20 00:00:00"  # Required. The start
                              time of the time range covered by the statistics.
                        },
                        "startTime": "2020-02-20 00:00:00",  # Required. The start time of
                          the time range covered by the statistics.
                        "url": "str",  # Required. The URL for the statistics.
                        "usageStats": {
                            "dedicatedCoreTime": "1 day, 0:00:00",  # Required. The
                              aggregated wall-clock time of the dedicated Compute Node cores being part
                              of the Pool.
                            "lastUpdateTime": "2020-02-20 00:00:00",  # Required. The
                              time at which the statistics were last updated. All statistics are
                              limited to the range between startTime and lastUpdateTime.
                            "startTime": "2020-02-20 00:00:00"  # Required. The start
                              time of the time range covered by the statistics.
                        }
                    },
                    "targetDedicatedNodes": 0,  # Optional. The desired number of dedicated
                      Compute Nodes in the Pool.
                    "targetLowPriorityNodes": 0,  # Optional. The desired number of
                      Spot/Low-priority Compute Nodes in the Pool.
                    "taskSchedulingPolicy": {
                        "nodeFillType": "str"  # Required. If not specified, the default is
                          spread. Known values are: "spread", "pack".
                    },
                    "taskSlotsPerNode": 0,  # Optional. The default value is 1. The maximum value
                      is the smaller of 4 times the number of cores of the vmSize of the pool or 256.
                    "url": "str",  # Optional. The URL of the Pool.
                    "userAccounts": [
                        {
                            "elevationLevel": "str",  # Optional. The default value is
                              nonAdmin. Known values are: "nonadmin", "admin".
                            "linuxUserConfiguration": {
                                "gid": 0,  # Optional. The uid and gid properties
                                  must be specified together or not at all. If not specified the
                                  underlying operating system picks the gid.
                                "sshPrivateKey": "str",  # Optional. The private key
                                  must not be password protected. The private key is used to
                                  automatically configure asymmetric-key based authentication for SSH
                                  between Compute Nodes in a Linux Pool when the Pool's
                                  enableInterNodeCommunication property is true (it is ignored if
                                  enableInterNodeCommunication is false). It does this by placing the
                                  key pair into the user's .ssh directory. If not specified,
                                  password-less SSH is not configured between Compute Nodes (no
                                  modification of the user's .ssh directory is done).
                                "uid": 0  # Optional. The uid and gid properties must
                                  be specified together or not at all. If not specified the underlying
                                  operating system picks the uid.
                            },
                            "name": "str",  # Required. The name of the user Account.
                            "password": "str",  # Required. The password for the user
                              Account.
                            "windowsUserConfiguration": {
                                "loginMode": "str"  # Optional. The default value for
                                  VirtualMachineConfiguration Pools is 'batch' and for
                                  CloudServiceConfiguration Pools is 'interactive'. Known values are:
                                  "batch", "interactive".
                            }
                        }
                    ],
                    "virtualMachineConfiguration": {
                        "containerConfiguration": {
                            "containerImageNames": [
                                "str"  # Optional. This is the full Image reference,
                                  as would be specified to "docker pull". An Image will be sourced from
                                  the default Docker registry unless the Image is fully qualified with
                                  an alternative registry.
                            ],
                            "containerRegistries": [
                                {
                                    "identityReference": {
                                        "resourceId": "str"  # Optional. The
                                          ARM resource id of the user assigned identity.
                                    },
                                    "password": "str",  # Optional. The password
                                      to log into the registry server.
                                    "registryServer": "str",  # Optional. If
                                      omitted, the default is "docker.io".
                                    "username": "str"  # Optional. The user name
                                      to log into the registry server.
                                }
                            ],
                            "type": "dockerCompatible"  # Default value is
                              "dockerCompatible". The container technology to be used. Has constant
                              value: "dockerCompatible".
                        },
                        "dataDisks": [
                            {
                                "caching": "str",  # Optional. The default value for
                                  caching is readwrite. For information about the caching options see:
                                  https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/27/exploring-windows-azure-drives-disks-and-images/.
                                  Known values are: "none", "readonly", "readwrite".
                                "diskSizeGB": 0,  # Required. The initial disk size
                                  in gigabytes.
                                "lun": 0,  # Required. The lun is used to uniquely
                                  identify each data disk. If attaching multiple disks, each should
                                  have a distinct lun. The value must be between 0 and 63, inclusive.
                                "storageAccountType": "str"  # Optional. If omitted,
                                  the default is "standard_lrs". Known values are: "standard_lrs",
                                  "premium_lrs".
                            }
                        ],
                        "diskEncryptionConfiguration": {
                            "targets": [
                                "str"  # Optional. If omitted, no disks on the
                                  compute nodes in the pool will be encrypted. On Linux pool, only
                                  "TemporaryDisk" is supported; on Windows pool, "OsDisk" and
                                  "TemporaryDisk" must be specified.
                            ]
                        },
                        "extensions": [
                            {
                                "autoUpgradeMinorVersion": bool,  # Optional.
                                  Indicates whether the extension should use a newer minor version if
                                  one is available at deployment time. Once deployed, however, the
                                  extension will not upgrade minor versions unless redeployed, even
                                  with this property set to true.
                                "name": "str",  # Required. The name of the virtual
                                  machine extension.
                                "protectedSettings": {},  # Optional. The extension
                                  can contain either protectedSettings or protectedSettingsFromKeyVault
                                  or no protected settings at all.
                                "provisionAfterExtensions": [
                                    "str"  # Optional. Collection of extension
                                      names after which this extension needs to be provisioned.
                                ],
                                "publisher": "str",  # Required. The name of the
                                  extension handler publisher.
                                "settings": {},  # Optional. Any object.
                                "type": "str",  # Required. The type of the
                                  extension.
                                "typeHandlerVersion": "str"  # Optional. The version
                                  of script handler.
                            }
                        ],
                        "imageReference": {
                            "exactVersion": "str",  # Optional. The specific version of
                              the platform image or marketplace image used to create the node. This
                              read-only field differs from 'version' only if the value specified for
                              'version' when the pool was created was 'latest'.
                            "offer": "str",  # Optional. For example, UbuntuServer or
                              WindowsServer.
                            "publisher": "str",  # Optional. For example, Canonical or
                              MicrosoftWindowsServer.
                            "sku": "str",  # Optional. For example, 18.04-LTS or
                              2019-Datacenter.
                            "version": "str",  # Optional. A value of 'latest' can be
                              specified to select the latest version of an Image. If omitted, the
                              default is 'latest'.
                            "virtualMachineImageId": "str"  # Optional. This property is
                              mutually exclusive with other ImageReference properties. The Shared Image
                              Gallery Image must have replicas in the same region and must be in the
                              same subscription as the Azure Batch account. If the image version is not
                              specified in the imageId, the latest version will be used. For
                              information about the firewall settings for the Batch Compute Node agent
                              to communicate with the Batch service see
                              https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration.
                        },
                        "licenseType": "str",  # Optional. This only applies to Images that
                          contain the Windows operating system, and should only be used when you hold
                          valid on-premises licenses for the Compute Nodes which will be deployed. If
                          omitted, no on-premises licensing discount is applied. Values are:"n"n
                          Windows_Server - The on-premises license is for Windows Server."n
                          Windows_Client - The on-premises license is for Windows Client.
                        "nodeAgentSKUId": "str",  # Required. The Batch Compute Node agent is
                          a program that runs on each Compute Node in the Pool, and provides the
                          command-and-control interface between the Compute Node and the Batch service.
                          There are different implementations of the Compute Node agent, known as SKUs,
                          for different operating systems. You must specify a Compute Node agent SKU
                          which matches the selected Image reference. To get the list of supported
                          Compute Node agent SKUs along with their list of verified Image references,
                          see the 'List supported Compute Node agent SKUs' operation.
                        "nodePlacementConfiguration": {
                            "policy": "str"  # Optional. Allocation policy used by Batch
                              Service to provision the nodes. If not specified, Batch will use the
                              regional policy. Known values are: "regional", "zonal".
                        },
                        "osDisk": {
                            "ephemeralOSDiskSettings": {
                                "placement": "CacheDisk"  # Optional. Default value
                                  is "CacheDisk". This property can be used by user in the request to
                                  choose the location e.g., cache disk space for Ephemeral OS disk
                                  provisioning. For more information on Ephemeral OS disk size
                                  requirements, please refer to Ephemeral OS disk size requirements for
                                  Windows VMs at
                                  https://docs.microsoft.com/en-us/azure/virtual-machines/windows/ephemeral-os-disks#size-requirements
                                  and Linux VMs at
                                  https://docs.microsoft.com/en-us/azure/virtual-machines/linux/ephemeral-os-disks#size-requirements.
                                  The only acceptable values to pass in are None and "CacheDisk". The
                                  default value is None.
                            }
                        },
                        "windowsConfiguration": {
                            "enableAutomaticUpdates": bool  # Optional. If omitted, the
                              default value is true.
                        }
                    },
                    "vmSize": "str"  # Optional. For information about available sizes of virtual
                      machines in Pools, see Choose a VM size for Compute Nodes in an Azure Batch Pool
                      (https://docs.microsoft.com/azure/batch/batch-pool-vm-sizes).
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-01-01.15.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_get_request(
            pool_id=pool_id,
            api_version=api_version,
            select=select,
            expand=expand,
            timeout=timeout,
            client_request_id=client_request_id,
            return_client_request_id=return_client_request_id,
            ocp_date=ocp_date,
            if_match=if_match,
            if_none_match=if_none_match,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "batchUrl": self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['client-request-id']=self._deserialize('str', response.headers.get('client-request-id'))
        response_headers['request-id']=self._deserialize('str', response.headers.get('request-id'))
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)

        return cast(JSON, deserialized)



    @distributed_trace
    def patch(  # pylint: disable=inconsistent-return-statements
        self,
        pool_id: str,
        pool_patch_parameter: JSON,
        *,
        timeout: Optional[int] = 30,
        client_request_id: Optional[str] = None,
        return_client_request_id: Optional[bool] = False,
        ocp_date: Optional[datetime.datetime] = None,
        if_match: Optional[str] = None,
        if_none_match: Optional[str] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> None:
        """Updates the properties of the specified Pool.

        This only replaces the Pool properties specified in the request. For example, if the Pool has a
        StartTask associated with it, and a request does not specify a StartTask element, then the Pool
        keeps the existing StartTask.

        :param pool_id: The ID of the Pool to update.
        :type pool_id: str
        :param pool_patch_parameter: The parameters for the request.
        :type pool_patch_parameter: JSON
        :keyword timeout: The maximum time that the server can spend processing the request, in
         seconds. The default is 30 seconds.
        :paramtype timeout: int
        :keyword client_request_id: The caller-generated request identity, in the form of a GUID with
         no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. Default value is
         None.
        :paramtype client_request_id: str
        :keyword return_client_request_id: Whether the server should return the client-request-id in
         the response. Default value is False.
        :paramtype return_client_request_id: bool
        :keyword ocp_date: The time the request was issued. Client libraries typically set this to the
         current system clock time; set it explicitly if you are calling the REST API directly. Default
         value is None.
        :paramtype ocp_date: ~datetime.datetime
        :keyword if_match: An ETag value associated with the version of the resource known to the
         client. The operation will be performed only if the resource's current ETag on the service
         exactly matches the value specified by the client. Default value is None.
        :paramtype if_match: str
        :keyword if_none_match: An ETag value associated with the version of the resource known to the
         client. The operation will be performed only if the resource's current ETag on the service does
         not match the value specified by the client. Default value is None.
        :paramtype if_none_match: str
        :keyword if_modified_since: A timestamp indicating the last modified time of the resource known
         to the client. The operation will be performed only if the resource on the service has been
         modified since the specified time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A timestamp indicating the last modified time of the resource
         known to the client. The operation will be performed only if the resource on the service has
         not been modified since the specified time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                pool_patch_parameter = {
                    "applicationPackageReferences": [
                        {
                            "applicationId": "str",  # Required. The ID of the
                              application to deploy.
                            "version": "str"  # Optional. If this is omitted on a Pool,
                              and no default version is specified for this application, the request
                              fails with the error code InvalidApplicationPackageReferences and HTTP
                              status code 409. If this is omitted on a Task, and no default version is
                              specified for this application, the Task fails with a pre-processing
                              error.
                        }
                    ],
                    "certificateReferences": [
                        {
                            "storeLocation": "str",  # Optional. The default value is
                              currentuser. This property is applicable only for Pools configured with
                              Windows Compute Nodes (that is, created with cloudServiceConfiguration,
                              or with virtualMachineConfiguration using a Windows Image reference). For
                              Linux Compute Nodes, the Certificates are stored in a directory inside
                              the Task working directory and an environment variable
                              AZ_BATCH_CERTIFICATES_DIR is supplied to the Task to query for this
                              location. For Certificates with visibility of 'remoteUser', a 'certs'
                              directory is created in the user's home directory (e.g.,
                              /home/{user-name}/certs) and Certificates are placed in that directory.
                              Known values are: "currentuser", "localmachine".
                            "storeName": "str",  # Optional. This property is applicable
                              only for Pools configured with Windows Compute Nodes (that is, created
                              with cloudServiceConfiguration, or with virtualMachineConfiguration using
                              a Windows Image reference). Common store names include: My, Root, CA,
                              Trust, Disallowed, TrustedPeople, TrustedPublisher, AuthRoot,
                              AddressBook, but any custom store name can also be used. The default
                              value is My.
                            "thumbprint": "str",  # Required. The thumbprint of the
                              Certificate.
                            "thumbprintAlgorithm": "str",  # Required. The algorithm with
                              which the thumbprint is associated. This must be sha1.
                            "visibility": [
                                "str"  # Optional. You can specify more than one
                                  visibility in this collection. The default is all Accounts.
                            ]
                        }
                    ],
                    "metadata": [
                        {
                            "name": "str",  # Required. The name of the metadata item.
                            "value": "str"  # Required. The value of the metadata item.
                        }
                    ],
                    "startTask": {
                        "commandLine": "str",  # Required. The command line does not run
                          under a shell, and therefore cannot take advantage of shell features such as
                          environment variable expansion. If you want to take advantage of such
                          features, you should invoke the shell in the command line, for example using
                          "cmd /c MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux. If the
                          command line refers to file paths, it should use a relative path (relative to
                          the Task working directory), or use the Batch provided environment variable
                          (https://docs.microsoft.com/en-us/azure/batch/batch-compute-node-environment-variables).
                        "containerSettings": {
                            "containerRunOptions": "str",  # Optional. These additional
                              options are supplied as arguments to the "docker create" command, in
                              addition to those controlled by the Batch Service.
                            "imageName": "str",  # Required. This is the full Image
                              reference, as would be specified to "docker pull". If no tag is provided
                              as part of the Image name, the tag ":latest" is used as a default.
                            "registry": {
                                "identityReference": {
                                    "resourceId": "str"  # Optional. The ARM
                                      resource id of the user assigned identity.
                                },
                                "password": "str",  # Optional. The password to log
                                  into the registry server.
                                "registryServer": "str",  # Optional. If omitted, the
                                  default is "docker.io".
                                "username": "str"  # Optional. The user name to log
                                  into the registry server.
                            },
                            "workingDirectory": "str"  # Optional. The default is
                              'taskWorkingDirectory'. Known values are: "taskWorkingDirectory",
                              "containerImageDefault".
                        },
                        "environmentSettings": [
                            {
                                "name": "str",  # Required. The name of the
                                  environment variable.
                                "value": "str"  # Optional. The value of the
                                  environment variable.
                            }
                        ],
                        "maxTaskRetryCount": 0,  # Optional. The Batch service retries a Task
                          if its exit code is nonzero. Note that this value specifically controls the
                          number of retries. The Batch service will try the Task once, and may then
                          retry up to this limit. For example, if the maximum retry count is 3, Batch
                          tries the Task up to 4 times (one initial try and 3 retries). If the maximum
                          retry count is 0, the Batch service does not retry the Task. If the maximum
                          retry count is -1, the Batch service retries the Task without limit, however
                          this is not recommended for a start task or any task. The default value is 0
                          (no retries).
                        "resourceFiles": [
                            {
                                "autoStorageContainerName": "str",  # Optional. The
                                  autoStorageContainerName, storageContainerUrl and httpUrl properties
                                  are mutually exclusive and one of them must be specified.
                                "blobPrefix": "str",  # Optional. The property is
                                  valid only when autoStorageContainerName or storageContainerUrl is
                                  used. This prefix can be a partial filename or a subdirectory. If a
                                  prefix is not specified, all the files in the container will be
                                  downloaded.
                                "fileMode": "str",  # Optional. This property applies
                                  only to files being downloaded to Linux Compute Nodes. It will be
                                  ignored if it is specified for a resourceFile which will be
                                  downloaded to a Windows Compute Node. If this property is not
                                  specified for a Linux Compute Node, then a default value of 0770 is
                                  applied to the file.
                                "filePath": "str",  # Optional. If the httpUrl
                                  property is specified, the filePath is required and describes the
                                  path which the file will be downloaded to, including the filename.
                                  Otherwise, if the autoStorageContainerName or storageContainerUrl
                                  property is specified, filePath is optional and is the directory to
                                  download the files to. In the case where filePath is used as a
                                  directory, any directory structure already associated with the input
                                  data will be retained in full and appended to the specified filePath
                                  directory. The specified relative path cannot break out of the Task's
                                  working directory (for example by using '..').
                                "httpUrl": "str",  # Optional. The
                                  autoStorageContainerName, storageContainerUrl and httpUrl properties
                                  are mutually exclusive and one of them must be specified. If the URL
                                  points to Azure Blob Storage, it must be readable from compute nodes.
                                  There are three ways to get such a URL for a blob in Azure storage:
                                  include a Shared Access Signature (SAS) granting read permissions on
                                  the blob, use a managed identity with read permission, or set the ACL
                                  for the blob or its container to allow public access.
                                "identityReference": {
                                    "resourceId": "str"  # Optional. The ARM
                                      resource id of the user assigned identity.
                                },
                                "storageContainerUrl": "str"  # Optional. The
                                  autoStorageContainerName, storageContainerUrl and httpUrl properties
                                  are mutually exclusive and one of them must be specified. This URL
                                  must be readable and listable from compute nodes. There are three
                                  ways to get such a URL for a container in Azure storage: include a
                                  Shared Access Signature (SAS) granting read and list permissions on
                                  the container, use a managed identity with read and list permissions,
                                  or set the ACL for the container to allow public access.
                            }
                        ],
                        "userIdentity": {
                            "autoUser": {
                                "elevationLevel": "str",  # Optional. The default
                                  value is nonAdmin. Known values are: "nonadmin", "admin".
                                "scope": "str"  # Optional. The default value is
                                  pool. If the pool is running Windows a value of Task should be
                                  specified if stricter isolation between tasks is required. For
                                  example, if the task mutates the registry in a way which could impact
                                  other tasks, or if certificates have been specified on the pool which
                                  should not be accessible by normal tasks but should be accessible by
                                  StartTasks. Known values are: "task", "pool".
                            },
                            "username": "str"  # Optional. The userName and autoUser
                              properties are mutually exclusive; you must specify one but not both.
                        },
                        "waitForSuccess": bool  # Optional. If true and the StartTask fails
                          on a Node, the Batch service retries the StartTask up to its maximum retry
                          count (maxTaskRetryCount). If the Task has still not completed successfully
                          after all retries, then the Batch service marks the Node unusable, and will
                          not schedule Tasks to it. This condition can be detected via the Compute Node
                          state and failure info details. If false, the Batch service will not wait for
                          the StartTask to complete. In this case, other Tasks can start executing on
                          the Compute Node while the StartTask is still running; and even if the
                          StartTask fails, new Tasks will continue to be scheduled on the Compute Node.
                          The default is true.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-01-01.15.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json; odata=minimalmetadata"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _content = pool_patch_parameter

        request = build_patch_request(
            pool_id=pool_id,
            api_version=api_version,
            content_type=content_type,
            content=_content,
            timeout=timeout,
            client_request_id=client_request_id,
            return_client_request_id=return_client_request_id,
            ocp_date=ocp_date,
            if_match=if_match,
            if_none_match=if_none_match,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "batchUrl": self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['client-request-id']=self._deserialize('str', response.headers.get('client-request-id'))
        response_headers['request-id']=self._deserialize('str', response.headers.get('request-id'))
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['DataServiceId']=self._deserialize('str', response.headers.get('DataServiceId'))


        if cls:
            return cls(pipeline_response, None, response_headers)



    @distributed_trace
    def disable_auto_scale(  # pylint: disable=inconsistent-return-statements
        self,
        pool_id: str,
        *,
        timeout: Optional[int] = 30,
        client_request_id: Optional[str] = None,
        return_client_request_id: Optional[bool] = False,
        ocp_date: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> None:
        """Disables automatic scaling for a Pool.

        Disables automatic scaling for a Pool.

        :param pool_id: The ID of the Pool on which to disable automatic scaling.
        :type pool_id: str
        :keyword timeout: The maximum time that the server can spend processing the request, in
         seconds. The default is 30 seconds.
        :paramtype timeout: int
        :keyword client_request_id: The caller-generated request identity, in the form of a GUID with
         no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. Default value is
         None.
        :paramtype client_request_id: str
        :keyword return_client_request_id: Whether the server should return the client-request-id in
         the response. Default value is False.
        :paramtype return_client_request_id: bool
        :keyword ocp_date: The time the request was issued. Client libraries typically set this to the
         current system clock time; set it explicitly if you are calling the REST API directly. Default
         value is None.
        :paramtype ocp_date: ~datetime.datetime
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-01-01.15.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_disable_auto_scale_request(
            pool_id=pool_id,
            api_version=api_version,
            timeout=timeout,
            client_request_id=client_request_id,
            return_client_request_id=return_client_request_id,
            ocp_date=ocp_date,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "batchUrl": self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['client-request-id']=self._deserialize('str', response.headers.get('client-request-id'))
        response_headers['request-id']=self._deserialize('str', response.headers.get('request-id'))
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['DataServiceId']=self._deserialize('str', response.headers.get('DataServiceId'))


        if cls:
            return cls(pipeline_response, None, response_headers)



    @distributed_trace
    def enable_auto_scale(  # pylint: disable=inconsistent-return-statements
        self,
        pool_id: str,
        pool_enable_auto_scale_parameter: JSON,
        *,
        timeout: Optional[int] = 30,
        client_request_id: Optional[str] = None,
        return_client_request_id: Optional[bool] = False,
        ocp_date: Optional[datetime.datetime] = None,
        if_match: Optional[str] = None,
        if_none_match: Optional[str] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> None:
        """Enables automatic scaling for a Pool.

        You cannot enable automatic scaling on a Pool if a resize operation is in progress on the Pool.
        If automatic scaling of the Pool is currently disabled, you must specify a valid autoscale
        formula as part of the request. If automatic scaling of the Pool is already enabled, you may
        specify a new autoscale formula and/or a new evaluation interval. You cannot call this API for
        the same Pool more than once every 30 seconds.

        :param pool_id: The ID of the Pool on which to enable automatic scaling.
        :type pool_id: str
        :param pool_enable_auto_scale_parameter: The parameters for the request.
        :type pool_enable_auto_scale_parameter: JSON
        :keyword timeout: The maximum time that the server can spend processing the request, in
         seconds. The default is 30 seconds.
        :paramtype timeout: int
        :keyword client_request_id: The caller-generated request identity, in the form of a GUID with
         no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. Default value is
         None.
        :paramtype client_request_id: str
        :keyword return_client_request_id: Whether the server should return the client-request-id in
         the response. Default value is False.
        :paramtype return_client_request_id: bool
        :keyword ocp_date: The time the request was issued. Client libraries typically set this to the
         current system clock time; set it explicitly if you are calling the REST API directly. Default
         value is None.
        :paramtype ocp_date: ~datetime.datetime
        :keyword if_match: An ETag value associated with the version of the resource known to the
         client. The operation will be performed only if the resource's current ETag on the service
         exactly matches the value specified by the client. Default value is None.
        :paramtype if_match: str
        :keyword if_none_match: An ETag value associated with the version of the resource known to the
         client. The operation will be performed only if the resource's current ETag on the service does
         not match the value specified by the client. Default value is None.
        :paramtype if_none_match: str
        :keyword if_modified_since: A timestamp indicating the last modified time of the resource known
         to the client. The operation will be performed only if the resource on the service has been
         modified since the specified time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A timestamp indicating the last modified time of the resource
         known to the client. The operation will be performed only if the resource on the service has
         not been modified since the specified time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                pool_enable_auto_scale_parameter = {
                    "autoScaleEvaluationInterval": "1 day, 0:00:00",  # Optional. The default
                      value is 15 minutes. The minimum and maximum value are 5 minutes and 168 hours
                      respectively. If you specify a value less than 5 minutes or greater than 168
                      hours, the Batch service rejects the request with an invalid property value
                      error; if you are calling the REST API directly, the HTTP status code is 400 (Bad
                      Request). If you specify a new interval, then the existing autoscale evaluation
                      schedule will be stopped and a new autoscale evaluation schedule will be started,
                      with its starting time being the time when this request was issued.
                    "autoScaleFormula": "str"  # Optional. The formula is checked for validity
                      before it is applied to the Pool. If the formula is not valid, the Batch service
                      rejects the request with detailed error information. For more information about
                      specifying this formula, see Automatically scale Compute Nodes in an Azure Batch
                      Pool
                      (https://azure.microsoft.com/en-us/documentation/articles/batch-automatic-scaling).
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-01-01.15.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json; odata=minimalmetadata"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _content = pool_enable_auto_scale_parameter

        request = build_enable_auto_scale_request(
            pool_id=pool_id,
            api_version=api_version,
            content_type=content_type,
            content=_content,
            timeout=timeout,
            client_request_id=client_request_id,
            return_client_request_id=return_client_request_id,
            ocp_date=ocp_date,
            if_match=if_match,
            if_none_match=if_none_match,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "batchUrl": self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['client-request-id']=self._deserialize('str', response.headers.get('client-request-id'))
        response_headers['request-id']=self._deserialize('str', response.headers.get('request-id'))
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['DataServiceId']=self._deserialize('str', response.headers.get('DataServiceId'))


        if cls:
            return cls(pipeline_response, None, response_headers)



    @distributed_trace
    def evaluate_auto_scale(
        self,
        pool_id: str,
        pool_evaluate_auto_scale_parameter: JSON,
        *,
        timeout: Optional[int] = 30,
        client_request_id: Optional[str] = None,
        return_client_request_id: Optional[bool] = False,
        ocp_date: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> JSON:
        """Gets the result of evaluating an automatic scaling formula on the Pool.

        This API is primarily for validating an autoscale formula, as it simply returns the result
        without applying the formula to the Pool. The Pool must have auto scaling enabled in order to
        evaluate a formula.

        :param pool_id: The ID of the Pool on which to evaluate the automatic scaling formula.
        :type pool_id: str
        :param pool_evaluate_auto_scale_parameter: The parameters for the request.
        :type pool_evaluate_auto_scale_parameter: JSON
        :keyword timeout: The maximum time that the server can spend processing the request, in
         seconds. The default is 30 seconds.
        :paramtype timeout: int
        :keyword client_request_id: The caller-generated request identity, in the form of a GUID with
         no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. Default value is
         None.
        :paramtype client_request_id: str
        :keyword return_client_request_id: Whether the server should return the client-request-id in
         the response. Default value is False.
        :paramtype return_client_request_id: bool
        :keyword ocp_date: The time the request was issued. Client libraries typically set this to the
         current system clock time; set it explicitly if you are calling the REST API directly. Default
         value is None.
        :paramtype ocp_date: ~datetime.datetime
        :return: JSON object
        :rtype: JSON
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                pool_evaluate_auto_scale_parameter = {
                    "autoScaleFormula": "str"  # Required. The formula is validated and its
                      results calculated, but it is not applied to the Pool. To apply the formula to
                      the Pool, 'Enable automatic scaling on a Pool'. For more information about
                      specifying this formula, see Automatically scale Compute Nodes in an Azure Batch
                      Pool
                      (https://azure.microsoft.com/en-us/documentation/articles/batch-automatic-scaling).
                }

                # response body for status code(s): 200
                response.json() == {
                    "error": {
                        "code": "str",  # Optional. An identifier for the autoscale error.
                          Codes are invariant and are intended to be consumed programmatically.
                        "message": "str",  # Optional. A message describing the autoscale
                          error, intended to be suitable for display in a user interface.
                        "values": [
                            {
                                "name": "str",  # Optional. The name in the
                                  name-value pair.
                                "value": "str"  # Optional. The value in the
                                  name-value pair.
                            }
                        ]
                    },
                    "results": "str",  # Optional. Each variable value is returned in the form
                      $variable=value, and variables are separated by semicolons.
                    "timestamp": "2020-02-20 00:00:00"  # Required. The time at which the
                      autoscale formula was last evaluated.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-01-01.15.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json; odata=minimalmetadata"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        _content = pool_evaluate_auto_scale_parameter

        request = build_evaluate_auto_scale_request(
            pool_id=pool_id,
            api_version=api_version,
            content_type=content_type,
            content=_content,
            timeout=timeout,
            client_request_id=client_request_id,
            return_client_request_id=return_client_request_id,
            ocp_date=ocp_date,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "batchUrl": self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['client-request-id']=self._deserialize('str', response.headers.get('client-request-id'))
        response_headers['request-id']=self._deserialize('str', response.headers.get('request-id'))
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['DataServiceId']=self._deserialize('str', response.headers.get('DataServiceId'))

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)

        return cast(JSON, deserialized)



    @distributed_trace
    def resize(  # pylint: disable=inconsistent-return-statements
        self,
        pool_id: str,
        pool_resize_parameter: JSON,
        *,
        timeout: Optional[int] = 30,
        client_request_id: Optional[str] = None,
        return_client_request_id: Optional[bool] = False,
        ocp_date: Optional[datetime.datetime] = None,
        if_match: Optional[str] = None,
        if_none_match: Optional[str] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> None:
        """Changes the number of Compute Nodes that are assigned to a Pool.

        You can only resize a Pool when its allocation state is steady. If the Pool is already
        resizing, the request fails with status code 409. When you resize a Pool, the Pool's allocation
        state changes from steady to resizing. You cannot resize Pools which are configured for
        automatic scaling. If you try to do this, the Batch service returns an error 409. If you resize
        a Pool downwards, the Batch service chooses which Compute Nodes to remove. To remove specific
        Compute Nodes, use the Pool remove Compute Nodes API instead.

        :param pool_id: The ID of the Pool to resize.
        :type pool_id: str
        :param pool_resize_parameter: The parameters for the request.
        :type pool_resize_parameter: JSON
        :keyword timeout: The maximum time that the server can spend processing the request, in
         seconds. The default is 30 seconds.
        :paramtype timeout: int
        :keyword client_request_id: The caller-generated request identity, in the form of a GUID with
         no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. Default value is
         None.
        :paramtype client_request_id: str
        :keyword return_client_request_id: Whether the server should return the client-request-id in
         the response. Default value is False.
        :paramtype return_client_request_id: bool
        :keyword ocp_date: The time the request was issued. Client libraries typically set this to the
         current system clock time; set it explicitly if you are calling the REST API directly. Default
         value is None.
        :paramtype ocp_date: ~datetime.datetime
        :keyword if_match: An ETag value associated with the version of the resource known to the
         client. The operation will be performed only if the resource's current ETag on the service
         exactly matches the value specified by the client. Default value is None.
        :paramtype if_match: str
        :keyword if_none_match: An ETag value associated with the version of the resource known to the
         client. The operation will be performed only if the resource's current ETag on the service does
         not match the value specified by the client. Default value is None.
        :paramtype if_none_match: str
        :keyword if_modified_since: A timestamp indicating the last modified time of the resource known
         to the client. The operation will be performed only if the resource on the service has been
         modified since the specified time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A timestamp indicating the last modified time of the resource
         known to the client. The operation will be performed only if the resource on the service has
         not been modified since the specified time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                pool_resize_parameter = {
                    "nodeDeallocationOption": "str",  # Optional. The default value is requeue.
                      Known values are: "requeue", "terminate", "taskcompletion", "retaineddata".
                    "resizeTimeout": "1 day, 0:00:00",  # Optional. The default value is 15
                      minutes. The minimum value is 5 minutes. If you specify a value less than 5
                      minutes, the Batch service returns an error; if you are calling the REST API
                      directly, the HTTP status code is 400 (Bad Request).
                    "targetDedicatedNodes": 0,  # Optional. The desired number of dedicated
                      Compute Nodes in the Pool.
                    "targetLowPriorityNodes": 0  # Optional. The desired number of
                      Spot/Low-priority Compute Nodes in the Pool.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-01-01.15.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json; odata=minimalmetadata"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _content = pool_resize_parameter

        request = build_resize_request(
            pool_id=pool_id,
            api_version=api_version,
            content_type=content_type,
            content=_content,
            timeout=timeout,
            client_request_id=client_request_id,
            return_client_request_id=return_client_request_id,
            ocp_date=ocp_date,
            if_match=if_match,
            if_none_match=if_none_match,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "batchUrl": self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['client-request-id']=self._deserialize('str', response.headers.get('client-request-id'))
        response_headers['request-id']=self._deserialize('str', response.headers.get('request-id'))
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['DataServiceId']=self._deserialize('str', response.headers.get('DataServiceId'))


        if cls:
            return cls(pipeline_response, None, response_headers)



    @distributed_trace
    def stop_resize(  # pylint: disable=inconsistent-return-statements
        self,
        pool_id: str,
        *,
        timeout: Optional[int] = 30,
        client_request_id: Optional[str] = None,
        return_client_request_id: Optional[bool] = False,
        ocp_date: Optional[datetime.datetime] = None,
        if_match: Optional[str] = None,
        if_none_match: Optional[str] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> None:
        """Stops an ongoing resize operation on the Pool.

        This does not restore the Pool to its previous state before the resize operation: it only stops
        any further changes being made, and the Pool maintains its current state. After stopping, the
        Pool stabilizes at the number of Compute Nodes it was at when the stop operation was done.
        During the stop operation, the Pool allocation state changes first to stopping and then to
        steady. A resize operation need not be an explicit resize Pool request; this API can also be
        used to halt the initial sizing of the Pool when it is created.

        :param pool_id: The ID of the Pool whose resizing you want to stop.
        :type pool_id: str
        :keyword timeout: The maximum time that the server can spend processing the request, in
         seconds. The default is 30 seconds.
        :paramtype timeout: int
        :keyword client_request_id: The caller-generated request identity, in the form of a GUID with
         no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. Default value is
         None.
        :paramtype client_request_id: str
        :keyword return_client_request_id: Whether the server should return the client-request-id in
         the response. Default value is False.
        :paramtype return_client_request_id: bool
        :keyword ocp_date: The time the request was issued. Client libraries typically set this to the
         current system clock time; set it explicitly if you are calling the REST API directly. Default
         value is None.
        :paramtype ocp_date: ~datetime.datetime
        :keyword if_match: An ETag value associated with the version of the resource known to the
         client. The operation will be performed only if the resource's current ETag on the service
         exactly matches the value specified by the client. Default value is None.
        :paramtype if_match: str
        :keyword if_none_match: An ETag value associated with the version of the resource known to the
         client. The operation will be performed only if the resource's current ETag on the service does
         not match the value specified by the client. Default value is None.
        :paramtype if_none_match: str
        :keyword if_modified_since: A timestamp indicating the last modified time of the resource known
         to the client. The operation will be performed only if the resource on the service has been
         modified since the specified time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A timestamp indicating the last modified time of the resource
         known to the client. The operation will be performed only if the resource on the service has
         not been modified since the specified time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-01-01.15.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_stop_resize_request(
            pool_id=pool_id,
            api_version=api_version,
            timeout=timeout,
            client_request_id=client_request_id,
            return_client_request_id=return_client_request_id,
            ocp_date=ocp_date,
            if_match=if_match,
            if_none_match=if_none_match,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "batchUrl": self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['client-request-id']=self._deserialize('str', response.headers.get('client-request-id'))
        response_headers['request-id']=self._deserialize('str', response.headers.get('request-id'))
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['DataServiceId']=self._deserialize('str', response.headers.get('DataServiceId'))


        if cls:
            return cls(pipeline_response, None, response_headers)



    @distributed_trace
    def update_properties(  # pylint: disable=inconsistent-return-statements
        self,
        pool_id: str,
        pool_update_properties_parameter: JSON,
        *,
        timeout: Optional[int] = 30,
        client_request_id: Optional[str] = None,
        return_client_request_id: Optional[bool] = False,
        ocp_date: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> None:
        """Updates the properties of the specified Pool.

        This fully replaces all the updatable properties of the Pool. For example, if the Pool has a
        StartTask associated with it and if StartTask is not specified with this request, then the
        Batch service will remove the existing StartTask.

        :param pool_id: The ID of the Pool to update.
        :type pool_id: str
        :param pool_update_properties_parameter: The parameters for the request.
        :type pool_update_properties_parameter: JSON
        :keyword timeout: The maximum time that the server can spend processing the request, in
         seconds. The default is 30 seconds.
        :paramtype timeout: int
        :keyword client_request_id: The caller-generated request identity, in the form of a GUID with
         no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. Default value is
         None.
        :paramtype client_request_id: str
        :keyword return_client_request_id: Whether the server should return the client-request-id in
         the response. Default value is False.
        :paramtype return_client_request_id: bool
        :keyword ocp_date: The time the request was issued. Client libraries typically set this to the
         current system clock time; set it explicitly if you are calling the REST API directly. Default
         value is None.
        :paramtype ocp_date: ~datetime.datetime
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                pool_update_properties_parameter = {
                    "applicationPackageReferences": [
                        {
                            "applicationId": "str",  # Required. The ID of the
                              application to deploy.
                            "version": "str"  # Optional. If this is omitted on a Pool,
                              and no default version is specified for this application, the request
                              fails with the error code InvalidApplicationPackageReferences and HTTP
                              status code 409. If this is omitted on a Task, and no default version is
                              specified for this application, the Task fails with a pre-processing
                              error.
                        }
                    ],
                    "certificateReferences": [
                        {
                            "storeLocation": "str",  # Optional. The default value is
                              currentuser. This property is applicable only for Pools configured with
                              Windows Compute Nodes (that is, created with cloudServiceConfiguration,
                              or with virtualMachineConfiguration using a Windows Image reference). For
                              Linux Compute Nodes, the Certificates are stored in a directory inside
                              the Task working directory and an environment variable
                              AZ_BATCH_CERTIFICATES_DIR is supplied to the Task to query for this
                              location. For Certificates with visibility of 'remoteUser', a 'certs'
                              directory is created in the user's home directory (e.g.,
                              /home/{user-name}/certs) and Certificates are placed in that directory.
                              Known values are: "currentuser", "localmachine".
                            "storeName": "str",  # Optional. This property is applicable
                              only for Pools configured with Windows Compute Nodes (that is, created
                              with cloudServiceConfiguration, or with virtualMachineConfiguration using
                              a Windows Image reference). Common store names include: My, Root, CA,
                              Trust, Disallowed, TrustedPeople, TrustedPublisher, AuthRoot,
                              AddressBook, but any custom store name can also be used. The default
                              value is My.
                            "thumbprint": "str",  # Required. The thumbprint of the
                              Certificate.
                            "thumbprintAlgorithm": "str",  # Required. The algorithm with
                              which the thumbprint is associated. This must be sha1.
                            "visibility": [
                                "str"  # Optional. You can specify more than one
                                  visibility in this collection. The default is all Accounts.
                            ]
                        }
                    ],
                    "metadata": [
                        {
                            "name": "str",  # Required. The name of the metadata item.
                            "value": "str"  # Required. The value of the metadata item.
                        }
                    ],
                    "startTask": {
                        "commandLine": "str",  # Required. The command line does not run
                          under a shell, and therefore cannot take advantage of shell features such as
                          environment variable expansion. If you want to take advantage of such
                          features, you should invoke the shell in the command line, for example using
                          "cmd /c MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux. If the
                          command line refers to file paths, it should use a relative path (relative to
                          the Task working directory), or use the Batch provided environment variable
                          (https://docs.microsoft.com/en-us/azure/batch/batch-compute-node-environment-variables).
                        "containerSettings": {
                            "containerRunOptions": "str",  # Optional. These additional
                              options are supplied as arguments to the "docker create" command, in
                              addition to those controlled by the Batch Service.
                            "imageName": "str",  # Required. This is the full Image
                              reference, as would be specified to "docker pull". If no tag is provided
                              as part of the Image name, the tag ":latest" is used as a default.
                            "registry": {
                                "identityReference": {
                                    "resourceId": "str"  # Optional. The ARM
                                      resource id of the user assigned identity.
                                },
                                "password": "str",  # Optional. The password to log
                                  into the registry server.
                                "registryServer": "str",  # Optional. If omitted, the
                                  default is "docker.io".
                                "username": "str"  # Optional. The user name to log
                                  into the registry server.
                            },
                            "workingDirectory": "str"  # Optional. The default is
                              'taskWorkingDirectory'. Known values are: "taskWorkingDirectory",
                              "containerImageDefault".
                        },
                        "environmentSettings": [
                            {
                                "name": "str",  # Required. The name of the
                                  environment variable.
                                "value": "str"  # Optional. The value of the
                                  environment variable.
                            }
                        ],
                        "maxTaskRetryCount": 0,  # Optional. The Batch service retries a Task
                          if its exit code is nonzero. Note that this value specifically controls the
                          number of retries. The Batch service will try the Task once, and may then
                          retry up to this limit. For example, if the maximum retry count is 3, Batch
                          tries the Task up to 4 times (one initial try and 3 retries). If the maximum
                          retry count is 0, the Batch service does not retry the Task. If the maximum
                          retry count is -1, the Batch service retries the Task without limit, however
                          this is not recommended for a start task or any task. The default value is 0
                          (no retries).
                        "resourceFiles": [
                            {
                                "autoStorageContainerName": "str",  # Optional. The
                                  autoStorageContainerName, storageContainerUrl and httpUrl properties
                                  are mutually exclusive and one of them must be specified.
                                "blobPrefix": "str",  # Optional. The property is
                                  valid only when autoStorageContainerName or storageContainerUrl is
                                  used. This prefix can be a partial filename or a subdirectory. If a
                                  prefix is not specified, all the files in the container will be
                                  downloaded.
                                "fileMode": "str",  # Optional. This property applies
                                  only to files being downloaded to Linux Compute Nodes. It will be
                                  ignored if it is specified for a resourceFile which will be
                                  downloaded to a Windows Compute Node. If this property is not
                                  specified for a Linux Compute Node, then a default value of 0770 is
                                  applied to the file.
                                "filePath": "str",  # Optional. If the httpUrl
                                  property is specified, the filePath is required and describes the
                                  path which the file will be downloaded to, including the filename.
                                  Otherwise, if the autoStorageContainerName or storageContainerUrl
                                  property is specified, filePath is optional and is the directory to
                                  download the files to. In the case where filePath is used as a
                                  directory, any directory structure already associated with the input
                                  data will be retained in full and appended to the specified filePath
                                  directory. The specified relative path cannot break out of the Task's
                                  working directory (for example by using '..').
                                "httpUrl": "str",  # Optional. The
                                  autoStorageContainerName, storageContainerUrl and httpUrl properties
                                  are mutually exclusive and one of them must be specified. If the URL
                                  points to Azure Blob Storage, it must be readable from compute nodes.
                                  There are three ways to get such a URL for a blob in Azure storage:
                                  include a Shared Access Signature (SAS) granting read permissions on
                                  the blob, use a managed identity with read permission, or set the ACL
                                  for the blob or its container to allow public access.
                                "identityReference": {
                                    "resourceId": "str"  # Optional. The ARM
                                      resource id of the user assigned identity.
                                },
                                "storageContainerUrl": "str"  # Optional. The
                                  autoStorageContainerName, storageContainerUrl and httpUrl properties
                                  are mutually exclusive and one of them must be specified. This URL
                                  must be readable and listable from compute nodes. There are three
                                  ways to get such a URL for a container in Azure storage: include a
                                  Shared Access Signature (SAS) granting read and list permissions on
                                  the container, use a managed identity with read and list permissions,
                                  or set the ACL for the container to allow public access.
                            }
                        ],
                        "userIdentity": {
                            "autoUser": {
                                "elevationLevel": "str",  # Optional. The default
                                  value is nonAdmin. Known values are: "nonadmin", "admin".
                                "scope": "str"  # Optional. The default value is
                                  pool. If the pool is running Windows a value of Task should be
                                  specified if stricter isolation between tasks is required. For
                                  example, if the task mutates the registry in a way which could impact
                                  other tasks, or if certificates have been specified on the pool which
                                  should not be accessible by normal tasks but should be accessible by
                                  StartTasks. Known values are: "task", "pool".
                            },
                            "username": "str"  # Optional. The userName and autoUser
                              properties are mutually exclusive; you must specify one but not both.
                        },
                        "waitForSuccess": bool  # Optional. If true and the StartTask fails
                          on a Node, the Batch service retries the StartTask up to its maximum retry
                          count (maxTaskRetryCount). If the Task has still not completed successfully
                          after all retries, then the Batch service marks the Node unusable, and will
                          not schedule Tasks to it. This condition can be detected via the Compute Node
                          state and failure info details. If false, the Batch service will not wait for
                          the StartTask to complete. In this case, other Tasks can start executing on
                          the Compute Node while the StartTask is still running; and even if the
                          StartTask fails, new Tasks will continue to be scheduled on the Compute Node.
                          The default is true.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-01-01.15.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json; odata=minimalmetadata"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _content = pool_update_properties_parameter

        request = build_update_properties_request(
            pool_id=pool_id,
            api_version=api_version,
            content_type=content_type,
            content=_content,
            timeout=timeout,
            client_request_id=client_request_id,
            return_client_request_id=return_client_request_id,
            ocp_date=ocp_date,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "batchUrl": self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['client-request-id']=self._deserialize('str', response.headers.get('client-request-id'))
        response_headers['request-id']=self._deserialize('str', response.headers.get('request-id'))
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['DataServiceId']=self._deserialize('str', response.headers.get('DataServiceId'))


        if cls:
            return cls(pipeline_response, None, response_headers)



    @distributed_trace
    def remove_nodes(  # pylint: disable=inconsistent-return-statements
        self,
        pool_id: str,
        node_remove_parameter: JSON,
        *,
        timeout: Optional[int] = 30,
        client_request_id: Optional[str] = None,
        return_client_request_id: Optional[bool] = False,
        ocp_date: Optional[datetime.datetime] = None,
        if_match: Optional[str] = None,
        if_none_match: Optional[str] = None,
        if_modified_since: Optional[datetime.datetime] = None,
        if_unmodified_since: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> None:
        """Removes Compute Nodes from the specified Pool.

        This operation can only run when the allocation state of the Pool is steady. When this
        operation runs, the allocation state changes from steady to resizing. Each request may remove
        up to 100 nodes.

        :param pool_id: The ID of the Pool from which you want to remove Compute Nodes.
        :type pool_id: str
        :param node_remove_parameter: The parameters for the request.
        :type node_remove_parameter: JSON
        :keyword timeout: The maximum time that the server can spend processing the request, in
         seconds. The default is 30 seconds.
        :paramtype timeout: int
        :keyword client_request_id: The caller-generated request identity, in the form of a GUID with
         no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. Default value is
         None.
        :paramtype client_request_id: str
        :keyword return_client_request_id: Whether the server should return the client-request-id in
         the response. Default value is False.
        :paramtype return_client_request_id: bool
        :keyword ocp_date: The time the request was issued. Client libraries typically set this to the
         current system clock time; set it explicitly if you are calling the REST API directly. Default
         value is None.
        :paramtype ocp_date: ~datetime.datetime
        :keyword if_match: An ETag value associated with the version of the resource known to the
         client. The operation will be performed only if the resource's current ETag on the service
         exactly matches the value specified by the client. Default value is None.
        :paramtype if_match: str
        :keyword if_none_match: An ETag value associated with the version of the resource known to the
         client. The operation will be performed only if the resource's current ETag on the service does
         not match the value specified by the client. Default value is None.
        :paramtype if_none_match: str
        :keyword if_modified_since: A timestamp indicating the last modified time of the resource known
         to the client. The operation will be performed only if the resource on the service has been
         modified since the specified time. Default value is None.
        :paramtype if_modified_since: ~datetime.datetime
        :keyword if_unmodified_since: A timestamp indicating the last modified time of the resource
         known to the client. The operation will be performed only if the resource on the service has
         not been modified since the specified time. Default value is None.
        :paramtype if_unmodified_since: ~datetime.datetime
        :return: None
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                node_remove_parameter = {
                    "nodeDeallocationOption": "str",  # Optional. The default value is requeue.
                      Known values are: "requeue", "terminate", "taskcompletion", "retaineddata".
                    "nodeList": [
                        "str"  # Required. A maximum of 100 nodes may be removed per request.
                    ],
                    "resizeTimeout": "1 day, 0:00:00"  # Optional. The default value is 15
                      minutes. The minimum value is 5 minutes. If you specify a value less than 5
                      minutes, the Batch service returns an error; if you are calling the REST API
                      directly, the HTTP status code is 400 (Bad Request).
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-01-01.15.0"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json; odata=minimalmetadata"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _content = node_remove_parameter

        request = build_remove_nodes_request(
            pool_id=pool_id,
            api_version=api_version,
            content_type=content_type,
            content=_content,
            timeout=timeout,
            client_request_id=client_request_id,
            return_client_request_id=return_client_request_id,
            ocp_date=ocp_date,
            if_match=if_match,
            if_none_match=if_none_match,
            if_modified_since=if_modified_since,
            if_unmodified_since=if_unmodified_since,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "batchUrl": self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers['client-request-id']=self._deserialize('str', response.headers.get('client-request-id'))
        response_headers['request-id']=self._deserialize('str', response.headers.get('request-id'))
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['DataServiceId']=self._deserialize('str', response.headers.get('DataServiceId'))


        if cls:
            return cls(pipeline_response, None, response_headers)


