# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
import sys
from typing import Any, Callable, Dict, Iterable, Optional, TypeVar

from msrest import Serializer

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict
if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore
JSON = MutableMapping[str, Any] # pylint: disable=unsubscriptable-object
T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False

def build_list_supported_images_request(
    *,
    filter: Optional[str] = None,
    max_results: Optional[int] = 1000,
    timeout: Optional[int] = 30,
    client_request_id: Optional[str] = None,
    return_client_request_id: Optional[bool] = False,
    ocp_date: Optional[datetime.datetime] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-01-01.15.0"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/supportedimages"

    # Construct parameters
    if filter is not None:
        _params['$filter'] = _SERIALIZER.query("filter", filter, 'str')
    if max_results is not None:
        _params['maxresults'] = _SERIALIZER.query("max_results", max_results, 'int', maximum=1000, minimum=1)
    if timeout is not None:
        _params['timeout'] = _SERIALIZER.query("timeout", timeout, 'int')
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    if client_request_id is not None:
        _headers['client-request-id'] = _SERIALIZER.header("client_request_id", client_request_id, 'str')
    if return_client_request_id is not None:
        _headers['return-client-request-id'] = _SERIALIZER.header("return_client_request_id", return_client_request_id, 'bool')
    if ocp_date is not None:
        _headers['ocp-date'] = _SERIALIZER.header("ocp_date", ocp_date, 'rfc-1123')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_list_pool_node_counts_request(
    *,
    filter: Optional[str] = None,
    max_results: Optional[int] = 10,
    timeout: Optional[int] = 30,
    client_request_id: Optional[str] = None,
    return_client_request_id: Optional[bool] = False,
    ocp_date: Optional[datetime.datetime] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-01-01.15.0"))  # type: str
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = "/nodecounts"

    # Construct parameters
    if filter is not None:
        _params['$filter'] = _SERIALIZER.query("filter", filter, 'str')
    if max_results is not None:
        _params['maxresults'] = _SERIALIZER.query("max_results", max_results, 'int', maximum=10, minimum=1)
    if timeout is not None:
        _params['timeout'] = _SERIALIZER.query("timeout", timeout, 'int')
    _params['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    if client_request_id is not None:
        _headers['client-request-id'] = _SERIALIZER.header("client_request_id", client_request_id, 'str')
    if return_client_request_id is not None:
        _headers['return-client-request-id'] = _SERIALIZER.header("return_client_request_id", return_client_request_id, 'bool')
    if ocp_date is not None:
        _headers['ocp-date'] = _SERIALIZER.header("ocp_date", ocp_date, 'rfc-1123')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )

class AccountOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure-batch.BatchServiceClient`'s
        :attr:`account` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")


    @distributed_trace
    def list_supported_images(
        self,
        *,
        filter: Optional[str] = None,
        max_results: Optional[int] = 1000,
        timeout: Optional[int] = 30,
        client_request_id: Optional[str] = None,
        return_client_request_id: Optional[bool] = False,
        ocp_date: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Lists all Virtual Machine Images supported by the Azure Batch service.

        Lists all Virtual Machine Images supported by the Azure Batch service.

        :keyword filter: An OData $filter clause. For more information on constructing this filter, see
         https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-support-images.
         Default value is None.
        :paramtype filter: str
        :keyword max_results: The maximum number of items to return in the response. A maximum of 1000
         results will be returned. Default value is 1000.
        :paramtype max_results: int
        :keyword timeout: The maximum time that the server can spend processing the request, in
         seconds. The default is 30 seconds.
        :paramtype timeout: int
        :keyword client_request_id: The caller-generated request identity, in the form of a GUID with
         no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. Default value is
         None.
        :paramtype client_request_id: str
        :keyword return_client_request_id: Whether the server should return the client-request-id in
         the response. Default value is False.
        :paramtype return_client_request_id: bool
        :keyword ocp_date: The time the request was issued. Client libraries typically set this to the
         current system clock time; set it explicitly if you are calling the REST API directly. Default
         value is None.
        :paramtype ocp_date: ~datetime.datetime
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "odata.nextLink": "str",  # Optional. The URL to get the next set of results.
                    "value": [
                        {
                            "batchSupportEndOfLife": "2020-02-20 00:00:00",  # Optional.
                              The time when the Azure Batch service will stop accepting create Pool
                              requests for the Image.
                            "capabilities": [
                                "str"  # Optional. Not every capability of the Image
                                  is listed. Capabilities in this list are considered of special
                                  interest and are generally related to integration with other features
                                  in the Azure Batch service.
                            ],
                            "imageReference": {
                                "exactVersion": "str",  # Optional. The specific
                                  version of the platform image or marketplace image used to create the
                                  node. This read-only field differs from 'version' only if the value
                                  specified for 'version' when the pool was created was 'latest'.
                                "offer": "str",  # Optional. For example,
                                  UbuntuServer or WindowsServer.
                                "publisher": "str",  # Optional. For example,
                                  Canonical or MicrosoftWindowsServer.
                                "sku": "str",  # Optional. For example, 18.04-LTS or
                                  2019-Datacenter.
                                "version": "str",  # Optional. A value of 'latest'
                                  can be specified to select the latest version of an Image. If
                                  omitted, the default is 'latest'.
                                "virtualMachineImageId": "str"  # Optional. This
                                  property is mutually exclusive with other ImageReference properties.
                                  The Shared Image Gallery Image must have replicas in the same region
                                  and must be in the same subscription as the Azure Batch account. If
                                  the image version is not specified in the imageId, the latest version
                                  will be used. For information about the firewall settings for the
                                  Batch Compute Node agent to communicate with the Batch service see
                                  https://docs.microsoft.com/en-us/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration.
                            },
                            "nodeAgentSKUId": "str",  # Required. The ID of the Compute
                              Node agent SKU which the Image supports.
                            "osType": "str",  # Required. The type of operating system
                              (e.g. Windows or Linux) of the Image. Known values are: "linux",
                              "windows".
                            "verificationType": "str"  # Required. Whether the Azure
                              Batch service actively verifies that the Image is compatible with the
                              associated Compute Node agent SKU. Known values are: "verified",
                              "unverified".
                        }
                    ]
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-01-01.15.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_list_supported_images_request(
                    api_version=api_version,
                    filter=filter,
                    max_results=max_results,
                    timeout=timeout,
                    client_request_id=client_request_id,
                    return_client_request_id=return_client_request_id,
                    ocp_date=ocp_date,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "batchUrl": self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                
                request = build_list_supported_images_request(
                    client_request_id=client_request_id,
                    return_client_request_id=return_client_request_id,
                    ocp_date=ocp_date,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "batchUrl": self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(next_link, **path_format_arguments)  # type: ignore

                path_format_arguments = {
                    "batchUrl": self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("odata.nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
                request,
                stream=False,
                **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )


    @distributed_trace
    def list_pool_node_counts(
        self,
        *,
        filter: Optional[str] = None,
        max_results: Optional[int] = 10,
        timeout: Optional[int] = 30,
        client_request_id: Optional[str] = None,
        return_client_request_id: Optional[bool] = False,
        ocp_date: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Gets the number of Compute Nodes in each state, grouped by Pool. Note that the numbers returned
        may not always be up to date. If you need exact node counts, use a list query.

        :keyword filter: An OData $filter clause. For more information on constructing this filter, see
         https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch. Default value is
         None.
        :paramtype filter: str
        :keyword max_results: The maximum number of items to return in the response. Default value is
         10.
        :paramtype max_results: int
        :keyword timeout: The maximum time that the server can spend processing the request, in
         seconds. The default is 30 seconds.
        :paramtype timeout: int
        :keyword client_request_id: The caller-generated request identity, in the form of a GUID with
         no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. Default value is
         None.
        :paramtype client_request_id: str
        :keyword return_client_request_id: Whether the server should return the client-request-id in
         the response. Default value is False.
        :paramtype return_client_request_id: bool
        :keyword ocp_date: The time the request was issued. Client libraries typically set this to the
         current system clock time; set it explicitly if you are calling the REST API directly. Default
         value is None.
        :paramtype ocp_date: ~datetime.datetime
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "odata.nextLink": "str",  # Optional. The URL to get the next set of results.
                    "value": [
                        {
                            "dedicated": {
                                "creating": 0,  # Required. The number of Compute
                                  Nodes in the creating state.
                                "idle": 0,  # Required. The number of Compute Nodes
                                  in the idle state.
                                "leavingPool": 0,  # Required. The number of Compute
                                  Nodes in the leavingPool state.
                                "offline": 0,  # Required. The number of Compute
                                  Nodes in the offline state.
                                "preempted": 0,  # Required. The number of Compute
                                  Nodes in the preempted state.
                                "rebooting": 0,  # Required. The count of Compute
                                  Nodes in the rebooting state.
                                "reimaging": 0,  # Required. The number of Compute
                                  Nodes in the reimaging state.
                                "running": 0,  # Required. The number of Compute
                                  Nodes in the running state.
                                "startTaskFailed": 0,  # Required. The number of
                                  Compute Nodes in the startTaskFailed state.
                                "starting": 0,  # Required. The number of Compute
                                  Nodes in the starting state.
                                "total": 0,  # Required. The total number of Compute
                                  Nodes.
                                "unknown": 0,  # Required. The number of Compute
                                  Nodes in the unknown state.
                                "unusable": 0,  # Required. The number of Compute
                                  Nodes in the unusable state.
                                "waitingForStartTask": 0  # Required. The number of
                                  Compute Nodes in the waitingForStartTask state.
                            },
                            "lowPriority": {
                                "creating": 0,  # Required. The number of Compute
                                  Nodes in the creating state.
                                "idle": 0,  # Required. The number of Compute Nodes
                                  in the idle state.
                                "leavingPool": 0,  # Required. The number of Compute
                                  Nodes in the leavingPool state.
                                "offline": 0,  # Required. The number of Compute
                                  Nodes in the offline state.
                                "preempted": 0,  # Required. The number of Compute
                                  Nodes in the preempted state.
                                "rebooting": 0,  # Required. The count of Compute
                                  Nodes in the rebooting state.
                                "reimaging": 0,  # Required. The number of Compute
                                  Nodes in the reimaging state.
                                "running": 0,  # Required. The number of Compute
                                  Nodes in the running state.
                                "startTaskFailed": 0,  # Required. The number of
                                  Compute Nodes in the startTaskFailed state.
                                "starting": 0,  # Required. The number of Compute
                                  Nodes in the starting state.
                                "total": 0,  # Required. The total number of Compute
                                  Nodes.
                                "unknown": 0,  # Required. The number of Compute
                                  Nodes in the unknown state.
                                "unusable": 0,  # Required. The number of Compute
                                  Nodes in the unusable state.
                                "waitingForStartTask": 0  # Required. The number of
                                  Compute Nodes in the waitingForStartTask state.
                            },
                            "poolId": "str"  # Required. The ID of the Pool.
                        }
                    ]
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        api_version = kwargs.pop('api_version', _params.pop('api-version', "2022-01-01.15.0"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_list_pool_node_counts_request(
                    api_version=api_version,
                    filter=filter,
                    max_results=max_results,
                    timeout=timeout,
                    client_request_id=client_request_id,
                    return_client_request_id=return_client_request_id,
                    ocp_date=ocp_date,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "batchUrl": self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                
                request = build_list_pool_node_counts_request(
                    client_request_id=client_request_id,
                    return_client_request_id=return_client_request_id,
                    ocp_date=ocp_date,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "batchUrl": self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(next_link, **path_format_arguments)  # type: ignore

                path_format_arguments = {
                    "batchUrl": self._serialize.url("self._config.batch_url", self._config.batch_url, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("odata.nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # pylint: disable=protected-access
                request,
                stream=False,
                **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )

